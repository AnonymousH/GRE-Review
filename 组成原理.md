## 第1章 计算机系统概述



### 1.3 计算机性能指标

#### 1.3.1 计算机的主要性能指标

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-12</font>

1. **机器字长**

&emsp;&emsp;机器字长是指计算机**进行一次整数运算(即定点整数运算)**所能处理的**二进制数据的位数**，通常与**CPU的寄存器位数**、**加法器**有关。机器字长一般等于内部寄存器的大小，**字长越长，数的表示范围越大，计算精度越高**。计算机字长通常选定为字节(8位)的整数倍。不同计算机，字长可以不同。

2. **数据通路带宽**

&emsp;&emsp;数据通路带宽是数据总线**一次所能进行并行传送信息的位数**。**这里所说的数据通路宽度是指外部数据总线的宽度**，它与CPU内部的数据总线宽度(内部寄存器的大小)有可能不同。

**【注】**各个子系统通过数据总线连接形成的数据传送路径称为数据通路。

3. **主存容量**

&emsp;&emsp;主存容量是指主存存储器所能存储的最大容量，**通常以字节来衡量**，也可以用**字数&times;字长(如512k&times;16位)**来表示存储容量。其中，**MAR的位数反映存储单元的个数**，MAR的位数**反映可寻址范围的最大值(而不一定是实际存储器的存储容量)**。

- 例子

<img src="C:\Users\HP\Desktop\组成原理\1.3.1-1.png" alt="1.3.1-1" style="zoom:80%;" />

4. **运算速率**

**（1）吞吐量和响应时间**

- **吞吐量**：指系统在单位时间被处理请求的数量。它取决于信息能多快地输入内存，CPU能多块地取指令，数据能多块地从内存取出或存入，以及所得结果能多块地从内存送给一台外部设备。这些步骤中的每步都关系到主存，因此**系统吞吐量主要取决于主存的存储周期**。

- **响应时间**：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括**CPU时间**(运行一个程序花费的时间)与**等待时间**(用与磁盘访问、存储器访问、I/O操作、操作系统开销等的时间)。

**（2）主频和CPU时钟周期**

- **CPU时钟周期**：通常为**节拍脉冲或T周期**，即**主频的倒数**，它**是CPU中最小的时间单位**，每个动作至少需要1个时钟周期。

- **主频(CPU的时钟频率)**：机器内部主时钟的频率，是衡量机器速度的重要参数。主频的倒数是CPU的时钟周期。**对于同一型号的计算机，其主频越高，完成指令的一个执行步骤所需的时间就越短，执行指令的速度就越快**。

**【注】**主频通常以MHz(兆赫兹)为单位，1HZ表示每秒一个时钟周期。

**（3）CPI(Clock cycle Per Instruction)**：即执行一条指令所需的时钟周期数。

**（4）CPU执行时间**：指运行一个程序所花费的时间
$$
CPU的执行时间=CPU时钟周期数/主频=(指令条数\times CPI)/主频
$$
上述表明，CPU的性能(执行时间)取决于**① 主频 ② CPI ③ 指令条数**

**（5）MIPS、MFLOPS、GLOPS和TFLOPS**

- **MIPS(Million Instructions Per Second)**，即每秒执行多少百万条指令。

$$
MIPS=指令条数/(执行时间\times10^6)=主频/CPI
$$

- **MFLOPS(Mega Floating-point Operations Per Second)**，即每秒执行多少百万次浮点运算。

$$
MFLOPS=浮点操作次数/(执行时间\times10^6)
$$

- **GFLOPS(Giga Floating-point Operations Per Second)**，即每秒执行多少十亿次浮点运算。

$$
GFLOPS=浮点操作次数/(执行时间\times10^9)
$$

- TFLOPS(Tera Floating-point Operations Per Second)，即每秒执行多少万亿次浮点运算。

$$
TFLOPS=浮点操作次数/(执行时间\times10^{12})
$$

#### 1.3.2 几个专业术语

<img src="C:\Users\HP\Desktop\组成原理\1.3.2-1.png" alt="1.3.2-1" style="zoom:80%;" />





## 第2章 数据的表示与运算



### 2.2 定点数的表示与运算

#### 2.2.1 定点数的表示

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-13</font>

1. **无符号数和有符号数的表示**

**1）无符号数**：指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为8位，则数的表示范围为0~2<sup>8</sup>，即0~255。

**2）有符号数**：通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。有符号数的机器表示有**原码**、**补码**、**反码**和**移码**。用$[X]_{原}$表示原码，$[X]_{补}$表示补码，$[X]_{反}$表示反码，$[X]_{移}$表示移码。



2. **机器数的定点表示**

**（1）定点小数**

&emsp;&emsp;定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分之前。设机器字长为n+1位，如图所示：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-1.png" alt="2.2.1-1" style="zoom:80%;" />

**（2）定点整数**

&emsp;&emsp;定点整数是纯整数，约定小数点位置在有效数值最低位之后。设机器字长为n+1位，如图所示：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-2.png" alt="2.2.1-2" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-3.png" alt="2.2.1-3" style="zoom:80%;" />



3. **原码、补码、反码、移码**

**（1）原码表示法**

- **纯小数的原码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-4.png" alt="2.2.1-4" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-5.png" alt="2.2.1-5" style="zoom:80%;" />

表示范围：若字长为n+1，$-(1-2^{-n})\le x \le 1-2^{-n}$（关于原点对称）

- **纯整数的原码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-6.png" alt="2.2.1-6" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-7.png" alt="2.2.1-7" style="zoom:80%;" />

表示范围：若字长为n+1，$-(2^n-1)\le x \le 2^n -1$（关于原点对称）

**【注】**真值的原码表示有正零和负零两种形式，即$[+0]_{原}=00000$和$[-0]_{原}=10000$

**（2）补码表示法**

- **纯小数的补码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-8.png" alt="2.2.1-8" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-9.png" alt="2.2.1-9" style="zoom:80%;" />

表示范围：若字长为n+1，$-1\le x \le 1-2^{-n}$（比原码多表示-1）

- **纯整数的补码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-10.png" alt="2.2.1-10" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-11.png" alt="2.2.1-11" style="zoom:80%;" />

表示范围：若字长为n+1，$-2^n \le x \le 2^n-1$（比原码多表示$-2^n$）

**【注】**真值零的补码表示是唯一的，即$[+0]_{补}=[-0]_{补}=0.0000$

- **由原码求补码**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-12.png" alt="2.2.1-12" style="zoom:80%;" />

- **补码的算术移位**

将$[x]_{补}$的符号位与数值一起右移一位并保持原符号位的值不变，可实现除法功能(除以2)。

变形补码，又称为模4补码，双符号位的补码小数，其定义为

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-13.png" alt="2.2.1-13" style="zoom:80%;" />

模4补码双符号位00表示正，11表示负，用在完成算术运算的ALU部件中。

**（3）反码表示**

反码通常用来作为原码求补码或补码求原码的中间过度。

- **纯小数的反码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-15.png" alt="2.2.1-15" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-14.png" alt="2.2.1-14" style="zoom:80%;" />

表示范围：若字长为n+1，即$-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）

**【注】**真值零的反码表示不唯一，负数的反码符号为“1”，数值部分求反，$[+0]_{反}=0.0000$，$[-0]_{反}=1.1111$

- **纯整数的反码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-16.png" alt="2.2.1-16" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-17.png" alt="2.2.1-17" style="zoom:80%;" />

表示范围：若字长为n+1，即$-(2^n-1)\le x\le 2^n-1$（关于原点对称）

- **真值、原码、补码及$[-x]_{补}$的转换规律**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-18.png" alt="2.2.1-18" style="zoom:80%;" />

**（4）移码表示法**

移码常用来表示浮点数的阶码，它只能表示整数。
$$
[x]_{移}=2^n+x\quad (2^n > x\ge -2^n,其中机器字长为n+1)
$$
例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-19.png" alt="2.2.1-19" style="zoom:80%;" />

- **移码的特点**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-20.png" alt="2.2.1-20" style="zoom:80%;" />



#### 2.2.3 强制类型转换

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-12,2010-14</font>

1. **有符号$\rightarrow$无符号**

```c
int main() {
    short x = -4321;
    unsigned short y = (unsigned short)x;
    printf("x=%d, y=%u\n",x,y);
}
```

![2-2-1](C:\Users\HP\Desktop\组成原理\2-2-1.png)

其中，$x$为补码表示，$y$为无符号真值。

2. **无符号$\rightarrow$有符号**

```C
int main() {
    unsigned short x = 65535;
    short y = (short)x;
    printf("x=%u, y=%d\n",x,y);
}
```

在采用补码的机器上，$x=65535, y=-1$

3. **大字长$\rightarrow$小字长**

```C
int main() {
 	int x = 165537, u = -34991;			//int型占用4B
    short y = (short)x, v = (short)u;	//short占用2B
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

>$x = 165537, y = -31071$
>
>$u=-34991, v = 30545$

其中$x,y,u,v$的16进制表示分别为0x000286a1，0x86a1，0xffff7751，0x7751。

**原则总结：**当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

4. **小字长$\rightarrow$大字长**

```c
int main() {
 	short x = -4321;
    int y = x;
    unsigned short u = (unsigned short)x;
    unsigned int v = u;
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

> $x = -4321, y = -4321$
>
> $u=61215, v = 61215$

其中$x,y,u,v$的16进制表示分别为0xef1f，0xffffef1f，0xef1f，0x0000ef1f

**原则总结：**当小字长变量向大字长变量强制类型转换时，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。



### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-14</font>

1. **浮点数的表示格式**

&emsp;&emsp;通常，浮点数表示为
$$
N=r^E \times M
$$
其中，$r$是浮点数的阶码的底，与尾数的基数相同，通常$r=2$。$E$为阶码，$M$为尾数。

![2.3.1-1](C:\Users\HP\Desktop\组成原理\2.3.1-1.png)

&emsp;&emsp;阶码是整数，**阶符$J_f$和阶码的位数$m$共同反映浮点数的表示范围及小数点的实际位置**。数符$S_f$代表浮点数的符号，**尾数的位数$n$反映浮点数的精度**。

2. **规格化浮点数**

- **左规**：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数左移一位，阶码减1(基数为2时)。**左规可能要进行多次**。
- **右规**：当浮点数运算的结果尾数出现溢出(双符号为01或10)时，将尾数算术右移一位、阶码加1(基数为2时)。**需要右规时，只需要进行一次**。

规格化浮点数的尾数$M$应满足条件$1/r \le |M| \le 1$。

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-2.png" alt="2.3.1-2" style="zoom:85%;" />

**【注】**

- 当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定为1，补码规格化数的尾数最高位一定与尾数符号位相反。
- 当浮点数尾数的基数为4时，原码规格化形式的尾数最高两位不全为0。
- 当浮点数尾数的基数为8时，原码规格化形式的尾数最高三位不全为0。

4. **IEEE 754 标准**

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-3.png" alt="2.3.1-3" style="zoom:85%;" />

&emsp;&emsp;IEEE 754 标准规定了常用的浮点格式有短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-4.png" alt="2.3.1-4" style="zoom:80%;" />

【注】**短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位数。临时浮点数又称扩展精度浮点数，无隐含位**。

> 例如，$(12)_{10}=(1100)_2$，将它规格化后结果为$1.1 \times 2^3$，其中整数部分“1”将不存储在23位尾数内。

&emsp;&emsp;IEEE 754标准中，规格化的短浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-127}
$$

#### 2.3.2 浮点数的加减运算

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-13</font>

&emsp;&emsp;浮点数运算特点是**阶码运算和尾数运算分开进行**，浮点数的**加减运算一律采用补码**。浮点数的加减运算分以下几步：

1. **对阶**

**小阶向大阶对齐原则**：阶码小的尾数右移一位(基数为2)，阶加1，直到两个数的阶码相等为止。

2. **尾数求和**

将对阶后的尾数按定点数加减运算规则运算。

3. **规格化**

以双符号为例，当尾数大于0时，其补码规格化形式为
$$
[S]_{补}=00.1**
$$
当尾数小于0时，其补码规格化形式为
$$
[S]_{补}=11.0**
$$
可见，当尾数的最高位数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种：

**1）左规**：当尾数出现00.0&times;&times;&times;或11.1&times;&times;&times;时，需左规，即尾数左移1位，和的阶码减1，知道尾数为00.1&times;&times;&times;或11.0&times;&times;&times;。

**2）右规**：当尾数求和结果溢出(如尾数为10.&times;&times;&times;或01.&times;&times;&times;时，需右规，即尾数右移一位，和的阶码加1。

**【注】**

- 左规相当于乘2，右规相当于除2。
- $[-1/2]_{补}=1.1000$不是规格化数，需要左规一次，$[-1]_{补}=1.0000$才是规格化数。

4. **舍入**

在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。

**1）“0”舍“1”入法**：在尾数右移时，被移去的最高位为0时，则舍去；被移去的最高数值位为1时，则在尾数的末位加1。这样做可能使尾数又溢出，此时需要再做一次右规。

**2）恒置“1”法**：尾数右移时，不论丢掉的最高位数值位是“1”还是"0"，都使右移后的尾数末位恒置"1"。

5. **溢出判断**

- 当尾数出现10.&times;&times;&times;或01.&times;&times;&times;时，并不表示溢出，只能将此数右规后，再根据阶码来判断运算结果是否溢出。
- 浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例子，当阶码的符号位出现“01”时，即**阶码大于最大阶码时**，表示**上溢**。当阶码的符号位出现“10”时，即**阶码小于最小阶码时**，表示**下溢**。



## 第3章 存储系统

### 3.3 半导体随机存储器

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-16</font>



#### 3.3.2 SRAM和DRAM



4. **SRAM和DRAM的比较**

<img src="C:\Users\HP\Desktop\组成原理\3.3.2-1.png" alt="3.3.2-1" style="zoom:90%;" />

#### 3.3.3 只读存储器ROM

1. **只读存储器的特点**

ROM和RAM都是支持**随机存取**的存储器，其中SRAM和DRAM均为易失性存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电了也不会丢失，它在计算机系统中只供读出的存储器。

​		1）**结构简单**，位密度比可读可写存储器的高。

​		2）具有**非易失性**，所以可靠性高。

2. **ROM的类型**

   1）掩膜式只读存储器MROM

   2）一次可编程只读存储器PROM

   3）可擦除可编程只读存储器EPROM

   4）闪速存储器(Flash Memory)

   5）固态硬盘(Solid State Driver，SSD)





### 3.4 主存储器与CPU的连接

#### 3.4.2 主存容量的扩展

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-15,2010-15</font>

1. **位扩展(并联)**

&emsp;&emsp;位扩展是使存储芯片的数据位数与CPU的数据线数相等。如图，用8片8K&times;1位的RAM芯片组成8K&times;8位的存储器。8位RAM芯片的地址线$A_{12}$~$A_0$、片选信号$\overline{CS}$、读写控制线$\overline{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。

![3.4.2-1](C:\Users\HP\Desktop\组成原理\3.4.2-1.png)

2. **字扩展(串联)**

&emsp;&emsp;字扩展是指增加存储器中字的数量，而位数不变。如图，用4片16K&times;8位的RAM芯片组成64K&times;8位的存储器。4片RAM芯片的数据线$D_0$~$D_7$和读写控制线$\overline{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}=00$时，译码输出端0有效，选最左边的1号芯片；$A_{15}A_{14}=01$时，译码输出端1有效，选中2号芯片，以此类推(在同一时间内只能有一个芯片被选中)

<img src="C:\Users\HP\Desktop\组成原理\3.4.2-2.png" alt="3.4.1-2" style="zoom:85%;" />

![3.4.1-3](C:\Users\HP\Desktop\组成原理\3.4.2-3.png)

3. **字位同时扩展法**

&emsp;&emsp;字位同时扩展既增加了存储字的数量，又增加了存储字长。如图，用用8片16K&times;4位的RAM芯片组成64K&times;8位的存储器。每两片构成一组16K&times;8位的存储器**(位扩展)**，4组便构成64K&times;8位**(字扩展)**。

![3.4.2-4](C:\Users\HP\Desktop\组成原理\3.4.2-4.png)



### 3.6 高速缓冲存储器Cache

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-21</font>

#### 3.6.1 程序访问的局部性原理

- **时间局部性**：最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序存在循环。
- **空间局部性**：最近的未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的。数据一般也是以向量、数组、表等形式簇聚第存储在一起的。

高速缓冲技术就是利用程序访问的局部性原理。



#### 3.6.3 Cache和主存的映射方式

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-14</font>

1. **直接映射**

- **映象规则**：主存中一块只能映象到Cache特定的一块中。

- Cache地址**计算公式**：

$$
b=B \ \text{mod} \ C_b
$$

其中，$b$是Cache的块号(又称Cache的行号)，$B$是主存的块号，$C_b$是Cache中的总块数。

- **地址结构**：

![3.6.3-1](C:\Users\HP\Desktop\组成原理\3.6.3-1.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-2.png" alt="3.6.3-2" style="zoom: 67%;" />

2. **全相联映射**

- **映象规则**：主存的任意一块可以映象到Cache中的任意一块。

- **地址结构**

  ![3.6.3-5](C:\Users\HP\Desktop\组成原理\3.6.3-5.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-3.png" alt="3.6.3-3" style="zoom: 67%;" />

3. **组相联映射**

- **映象规则**
  - 主存和Cache按同样大小划分成块和组
  - 主存和Cache组之间采用直接映象方式
  - 在两个对应的组内采用全相联映象方式

- **地址结构**

![3.6.3-6](C:\Users\HP\Desktop\组成原理\3.6.3-6.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-7.png" alt="3.6.3-7" style="zoom: 67%;" />



### 3.7 虚拟存储器

#### 3.7.5 快表(TLB)

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-17</font>

&emsp;&emsp;在页式或段式或段页式虚拟存储器中必须先去一次主存查页表或段表才取得数据。快表利用了**局部性原则**。快表存放在**高速缓冲器**中，**慢表(Page)**存放在**内存**中。快表只是慢表的一个副本，而且只存放了慢表中很少的一部分。

**【注1】**TLB是Page的一个很小副本，所以若TLB命中则Page一定命中。

**【注2】**在同时具有虚拟页式存储器(有TLB)和Cache的系统中，访问的顺序为：**TLB$\rightarrow$页表$\rightarrow$Cache$\rightarrow$主存**。CPU发出访存命令(逻辑地址)，先查找TLB和Page，将逻辑地址转换为物理地址，再查找相应的Cache块(与主存查找并行)。

**【注3】**若Cache命中，则说明所需页面已调入主存，Page必然命中，但TLB不一定命中；若Cache不命中，则并不能说明所需的页面未调入主存，和TLB和Page命中与否没有关系；若Page不命中，则说明所需页面未调入主存，当然Cache和快表也不会命中，执行调页策略。



## 第4章：指令系统





### 4.2 指令寻址方式

&emsp;&emsp;寻址方式是指寻找指令或操作数有效地址，即确定本条指令的数据地址及下一条待执行指令的地址的方法。

**【注1】A：形式地址**	**EA：有效地址**

**【注2】**\(A\)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应(A)就是寄存器中的数值，或相应内存单元的数值。

**【注3】**EA=(A)意思是有效地址是地址A中的值。

#### 4.2.1 指令寻址和数据寻址

&emsp;&emsp;寻址方式分为指令寻址和数据寻址两大类。寻找下一条要执行的指令地址称为**指令寻址**；寻找操作数的地址称为**数据寻址**。

1. **指令寻址**

   **1）顺序寻址**：通过程序计数器(PC)加1(1个指令字长)，自动形成下一条指令的地址。

   **2）跳跃寻址：**所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条下条指令地址的计算方式。

   【注】是否跳跃可能受到**状态寄存器**和**操作数**的控制，而跳跃到的地址分为**绝对地址**(由标记符直接得到)和**相对地址**(相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以**下一条指令仍然通过程序计数器(PC)给出**。

2. **数据寻址**

&emsp;&emsp;数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。

![4.2.1-1](C:\Users\HP\Desktop\组成原理\4.2.1-1.png)

#### 4.2.2 常见的数据寻址方式

1. **隐含寻址**

&emsp;&emsp;这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。

> 例：**单地址**的指令格式就不明显地在地址字段中指出第二个操作数的地址，规定**累加器(ACC)**作为第二个操作数地址。累加器(ACC)对单地址指令来说就是隐含寻址。

**优点**：缩短指令字长

**缺点**：增加存储器操作数或隐含地址的硬件。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-1.png" alt="4.2.2-1" style="zoom:80%;" />

2. **立即(数)寻址**

&emsp;&emsp;这种类型的指令的地址字段直接指出的不是操作数的地址，而是操作数的本身，又称为**立即数**。**数据采用补码的形式存放**。

**优点**：不访问主存，执行时间短。

**缺点**：A的位数限制了立即数的范围。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-2.png" alt="4.2.2-2" style="zoom:80%;" />

3. **直接寻址**

指令中的**形式地址A是操作数的真实地址EA**，即**EA=A**。

**优点**：简单，指令仅访问一次主存。

**缺点**：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-3.png" alt="4.2.2-3" style="zoom:80%;" />

4. **间接寻址**

&emsp;&emsp;**间接寻址是相对于直接寻址而言的**，指令的地址字段给出的形式地址不是操作数地址，而是操作数有效地址所在的存储单元，即**操作数地址的地址**，即**EA = (A)**。间接寻址可以是一次间接寻址，也可以是多次间接寻址。

**优点**：可扩大寻址范围(**有效地址EA的位数大于形式地址A的位数**)，便于编制程序(**用间接寻址可方便完成子程序的返回**)

**缺点**：指令在执行阶段需要多次访存，增大了时间开销。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-4.png" alt="4.2.2-4" style="zoom:80%;" />

5. **寄存器寻址**

&emsp;&emsp;寄存器寻址是指在指令字重直接给出操作数所在的寄存器编号，即$EA=R_i$，其操作数在$R_i$所指的寄存器内。

**优点**：不需要访问主存，执行速度快，**支持向量/矩阵运算**。

**缺点**：寄存器价格昂贵，计算机中的寄存器个数有限。

6. **寄存器间接寻址**

&emsp;&emsp;寄存器间接寻址是指在寄存器$R_i$中给出的不是操作数，而是操作数所在主存单元的地址，即$EA=(R_i)$。

**优点**：与一般间接寻址相比速度更快。

**缺点**：需要访问主存

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-5.png" alt="4.2.2-5" style="zoom:80%;" />

7. **相对寻址**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-16</font>

&emsp;&emsp;相对寻址是把程序计数器(PC)的内容加上形式地址A而形成的操作数的有效地址，即               **EA=(PC)+A**，其中A是相对于当前指令地址的位移量，可正可负，补码表示。

**优点**：操作数的地址不是固定的，它随PC值的变化而变化，且与指令之间总是相差一个固定值，因此**便于程序的浮动**。**相对寻址广泛利用于转移指令**。

**【注】**对于转移指令JMP A，当CPU从存储器中取出一个字节时，会自动执行(PC)+1->PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会自增2，即(PC) = X + 2，这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-6.png" alt="4.2.2-6" style="zoom:80%;" />

8. **基址寻址**

&emsp;&emsp;基址寻址是将CPU中的**基址寄存器(BR)**的内容加上指令格式中的形式地址A而形成操作数的有效地址。即**EA = (BR) + A**。其中基值寄存器既可以采用专用寄存器，又可以采用通用寄存器。

**优点**：可扩大寻址范围(**基址寄存器的位数大于形式地址A的位数**)，用户可以不用考虑自己的程序存于主存的哪个空间区域，有利于**多道程序的设计**，可用于**编制浮动程序**。

**缺点**：偏移量(形式地址A)的位数较短。

**【注1】**基址寄存器是**面向操作系统**的，其内容由操作系统或管理员确定，主要用于**解决程序逻辑空间与存储器的物理空间的无关性**。

**【注2】在程序执行的过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)**。采用通用寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍然是由操作系统确定。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-7.png" alt="4.2.2-7" style="zoom:80%;" />

9. **变址寻址**

&emsp;&emsp;变址寻址是指有效地址EA等于指令字中的形式地址A与**变址寄存器(IX)**的内容之和，即                 **EA = (IX) + A**。其中IX可为专业寄存器，也可以是通用寄存器。

**优点**：可扩大寻址范围(变址寄存器的位数大于形式地址A的位数)，**常用于数组处理**，可设定A为数组的首地址。**特别适合编制循环程序**。偏移量(变址寄存器IX)的位数足够以表示整个存储空间。

**【注】**变址寄存器是**面向用户的**，在程序执行的过程中，**变址寄存器可由用户改变(作为偏移量)，形式地址A不变(作为基地址)**。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-8.png" alt="4.2.2-8" style="zoom:80%;" />

10. **堆栈寄存器**

&emsp;&emsp;堆栈是存储器(或专用寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器为**堆栈指针(SP)**。堆栈可分为**硬堆栈**和**软堆栈**两种。

&emsp;&emsp;**寄存器堆栈又称为硬堆栈**。寄存器堆栈的成本比较高，不适合做大容量的堆栈；而从**主存划分一段区域做堆栈**是最常用的方法，这种堆栈称为**软堆栈**。

**【注】**采用堆栈结构的计算机系统中，**大部分指令表面上都表现为无操作数指令的形式**，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-9.png" alt="4.2.2-9" style="zoom:80%;" />



### 4.3 CISC和RISC的基本概念

#### 4.3.2 精简指令系统计算机(RISC)

<img src="C:\Users\HP\Desktop\组成原理\4-3-1.png" alt="4-3-1" style="zoom:80%;" />

#### 4.3.3 CISC和RISC的比较

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-17</font>

<img src="C:\Users\HP\Desktop\组成原理\4-3-2.png" alt="4-3-2" style="zoom:80%;" />



## 第5章 中央处理器

### 5.1 CPU的功能和基本结构

#### 5.1.1 CPU的功能

- **指令控制**：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
- **操作控制**：CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指定的要求进行动作。
- **时间控制**：为每条指令按时间顺序提供应有的控制信号。
- **数据加工**：对数据进行算术和逻辑运算。
- **中断处理**：对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 5.1.2 CPU的基本结构部

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-18</font>

<img src="C:\Users\HP\Desktop\组成原理\5.1.2-1.png" alt="5.1.2-1" style="zoom:90%;" />

1. **运算器**

&emsp;&emsp;运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理，它是对数据进行加工处理的中心。

**1）算术逻辑单元(ALU)**：主要功能是进行算术/逻辑运算。

**2）暂存寄存器**：用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有的内容。**暂时寄存器对应用程序员是透明的**。

**3）累加寄存器(ACC)**：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。

**4）通用寄存器组**：如AX、BX、CX、DX、SP等，用于存放操作数(包括源操作、目的操作数及中间结果)和各种地址信息。SP是堆栈指针，用于指示栈顶的地址。

**5）程序状态寄存器(PSW)**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如**溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)**等。PSW中的这些位参与并决定微操作的形成。

**6）移位器**：对操作数或运算结果进行移位运算。

**7）计数器(CT)**：控制乘除运算的操作步数。

2. **控制器**

&emsp;&emsp;控制器是整个系统的指挥中枢，在控制器的控制下，使运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。

&emsp;&emsp;控制器的基本功能是执行指令，**每条指令的执行是由控制器发出的一组微操作实现的**。

**1）程序计数器(PC)**：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以**PC有自增功能**。

**2）指令寄存器(IR)**：用于保存当前正在执行的那条指令。

**3）指令译码器**：仅对操作字段进行译码，向控制器提供特定的操作信号。

**4）存储器地址寄存器(MAR)**：用于存放所要访问的主存单元的地址。

**5）存储器数据寄存器(MDR)**：用于存放向主存写入的信息或从主存中读出信息。

**6）时序系统**：用于产生各种时序信号，它们都由统一时钟(CLOCK)分频得到。

**7）微操作信号发生器**：根据IR的内容(指令)、PSW的内容(状态信息)及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有**组合逻辑**和**存储逻辑**两种。

【注】CPU内部寄存器分为两类：一类是**用户可见的寄存器**，可对这类寄存器编程，如**通用寄存器**、**程序状态寄存器(PSW)**，**程序计数器(PC)**；另一类是**用户不可见的寄存器**，对用户是透明的，不可对这类寄存器进行编程，如**存储器地址寄存器(MAR)**、**存储器数据寄存器(MDR)**、**指令寄存器(IR)**。



### 5.2 指令的执行过程

#### 5.2.1 指令周期

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-11</font>

1. **概念**

&emsp;&emsp;CPU从主存中每取出并执行一条指令所需的全部时间称为**指令周期**，即CPU完成一条指令的时间。

&emsp;&emsp;指令周期常用若干个**机器周期**来表示，一个机器周期又包含若干**时钟周期**(也称为**节拍**或**T周期**，它是CPU操作的最基本单位)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。
$$
\begin{align}
机器周期 &= 主存周期 \\
时钟周期 &= 计算机主频的倒数 \\
计算机主频 &= 1s时钟周期数
\end{align}
$$

<img src="C:\Users\HP\Desktop\组成原理\5.2.1-1.png" alt="5.2.1-1" style="zoom:95%;" />



![5.2.1-2](C:\Users\HP\Desktop\组成原理\5.2.1-2.png)





### 5.3 数据通路的功能和基本结构



### 5.4 控制器的功能和工作原理

#### 5.4.1 控制器的结构和功能

<img src="C:\Users\HP\Desktop\组成原理\5.4.1-1.png" alt="5.4.1-1" style="zoom:80%;" />

控制器包括**指令寄存器IR**和**程序计数器PC**，它是计算机系统的指挥中心，控制器主要功能有：

1）从主存取出一条指令，并指出下一条指令在主存中的位置。

2）对指令进行译码或测试，产生相应的操作控制信息，以便启动规定的动作。

3）指挥控制CPU、主存、输入和输出设备之间的数据流动方向。

#### 5.4.2 硬布线控制器

1. **硬布线控制单元图**

&emsp;&emsp;指令的操作码是决定控制单元发出不同操作命令(控制信号)的关键。CU的输入信号如下：

1）经指令译码器产生的指令信息。

2）时序系统产生的机器周期信号和节拍信号。

3）来自执行单元的反馈信息即标志。

<img src="C:\Users\HP\Desktop\组成原理\5.4.2-1.png" alt="5.4.2-1" style="zoom:80%;" />

2. **硬布线控制器的时序系统及微操作**<img src="C:\Users\HP\Desktop\组成原理\5.4.2-2.png" alt="5.4.2-2" style="zoom:80%;" /><img src="C:\Users\HP\Desktop\组成原理\5.4.2-3.png" alt="5.4.2-3" style="zoom:80%;" />

3. **CU的控制方式**

   1）同步控制方式	2）异步控制方式	3）联合控制方式



#### 5.4.3 微程序控制器

&emsp;&emsp;微程序设计思想是将每条机器指令编写成一个微程序，每个微程序包含若干个微指令，每个微指令对应一个或几个微操作命令。目前，**大多数计算机都采用微程序设计技术**。

1. **微程序控制的基本概念**

1）**微命令**和**微操作**：一条机器指令可分解成一个微操作系列，这些**微操作是计算机中最基本的、不可再分解的操作**。在微程序控制的计算机中，将**控制部件向执行部件发出各种控制命令称为微命令**，它是构成控制序列的最小单位。**微命令是微操作的控制信号，微操作是微命令的执行过程**。

**【注】**在组合逻辑控制器中也有微命令和微操作两个概念，它们并非是微程序控制器专有的。

2）**微指令**与**微周期**：微指令是若干微命令的集合。存放微程序指令的控制存储器的单元地址称为微地址。微指令通常至少包含两大部分信息：

​	① **操作控制字段**：又称为微操作码字段，用于产生某一步操作所需的各种操作控制信号。

​	② **顺序控制字段**：又称微地址码字段，用于控制产生下一条要执行的微指令地址。

3）**主存储器**与**控制存储器**：主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器(CM)用于存放微程序，在CPU内部，用ROM实现。

4）**程序**与**微程序**：程序是指令的有序集合，用于完成特定的功能；微程序是微指令的有序集合，**一条指令的功能由一段微程序来实现**。

**【注】微程序是不面向用户的**，它是由计算机设计者事先编制好并存放在控制存储器中的。程序是面向用户的，是由软件设计人员事先编制好放在主存或辅存的。

- **注意区分的几个寄存器**

  ① **地址寄存器(MAR)**：用于存放主存的读/写地址。

  ② **微指令寄存器(CMAR)**：用于存放控制存储器的读/写指令的地址。

  ③ **指令寄存器(IR)**：用于存放从主存中读出的指令。

  ④ **微指令寄存器(CMDR)**：用于存放从控制存储器中取出的微指令。



2. **微程序控制器的组成和工作过程**

**（1）微程序控制器的基本结构**

​	① **控制存储器**：它是微程序控制器的核心部件，用于存放各指令对应的微程序。

​	② **微指令寄存器(CMDR)**：用于存放从CM中取出的微指令，它的位数同微指令字长相等。

​	③ **微地址形成部件**：用于产生初始微地址和后继微地址，以保证微指令的连续执行。

​	④ **微地址寄存器(CMAR)**：接收微地址形成部件送来的微地址，为在CM中读取微指令做准备。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-1.png" alt="5.4.3-1" style="zoom:80%;" />

**（3）微程序和机器指令**

&emsp;&emsp;通常，一条机器指令对应一个微程序。**由于任何一条机器指令的取指令操作都是相同的，因此可以将取指令操作的微命令统一编成一个微程序**，这个微程序只负责将指令从主存单元中取出并送至寄存器。

**【注】**若指令系统中具有**n**种机器指令，则控制寄存器中的微程序数至少是**n+1(1为公共取指微操作)**。



3. **微指令的编码方式**

**（1）直接编码(直接控制)方式**

&emsp;&emsp;直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令对应位设置成1或0即可。

**优点**：简单、直观、执行速度快，操作并行性好。

**缺点**：微指令字长过长，n个微命令就要求微指令的操作字段有n位。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-2.png" alt="5.4.3-2" style="zoom:80%;" />

**（2）字段直接编码方式**

&emsp;&emsp;将微指令的微命令字段分成若干小字段，把**互斥性微命令组合在同一字段中**，把**相容性微命令组合在不同字段中**，每个字段独立编码。

- **微命令字段的分段原则**
  - 互斥性命令分别在同一段中，相容性微命令分别在不同段中
  - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间
  - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3时，最多只能表示7个互斥的微命令，通常用000表示不操作。

**优点**：可以缩短微指令字长

**缺点**：因为要通过译码电路后再发出微命令，因此执行速度慢

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-3.png" alt="5.4.3-3" style="zoom:80%;" />

**（3）字段间接编码方式**

&emsp;&emsp;一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出微命令，故称为字段间接编码，又称隐式编码。



4. **微指令的地址形成方式**

后继地址的形成主要有以下两大基本类型：

1）**直接由微指令的下地址段给出(断定方式)**

2）**根据机器指令的操作码形成**

微指令序列地址形成方式还有以下几种：<img src="C:\Users\HP\Desktop\组成原理\5.4.3-4.png" alt="5.4.3-4" style="zoom: 80%;" />



5. **微指令的格式**

**1）水平型微指令**：从编码上看。直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。指令字中的一位对应一个控制信号，有输出时为1，否则为0。**一条水平型指令定义并执行几种并行的基本操作**。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-5.png" alt="5.4.3-5" style="zoom:80%;" />

**优点**：微程序短，执行速度快

**缺点**：微指令长，编写微程序比较麻烦

**2）垂直型微指令**：垂直型微指令的特点是采用类似机器指令操作码方式，在微指令中设置操作码字段，采用微操作码编译法，由微操作码规定微指令的功能。**一条垂直型微指令只能定义并执行一种基本操作**。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-6.png" alt="5.4.3-6" style="zoom: 80%;" />

**优点**：微指令短、简单、规整，便于编写微程序。

**缺点**：微程序长，执行速度慢，工作效率低。

**3）混合型微指令**：在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度快。

- **水平微指令 VS 垂直型微指令**

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-7.png" alt="5.4.3-7" style="zoom:80%;" />



#### 5.4.4 微程序 VS 硬布线

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-19</font>

<img src="C:\Users\HP\Desktop\组成原理\5.4-1.png" style="zoom:75%;" />



### 5.5 指令流水线

#### 5.5.1 指令流水线的基本概念

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-18</font>



3. **流水线方式的特点**

（1）把一个任务(一条指令或一个操作)分解为**几个有联系的子任务**，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短执行时间。

（2）流水线每个功能部件后面都要有一个**缓冲寄存器**，或称为锁存器，其作用是保存流水段的执行结果，供给下一流水段使用。

（3）流水线中各个**功能段的时间应尽量相等**，否则会引起堵塞、断流。

（4）只有连续不断地提供同一种任务时才能发挥流水线的效率，所以流水线的中处理的必须是**连续任务**。

（5）流水线需要有**装入时间**和**排空时间**。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。





#### 5.5.3 影响流水线的因素

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-19</font>

1. **结构相关(资源冲突)**

由于**多条指令在同一时刻争用同一资源**形成的冲突称为结构相关，有以下解决方案：

（1）前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期。

（2）单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重配置。



2. **数据相关(数据冲突)**

&emsp;&emsp;数据相关是指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令记为数据相关。解决方法如下

（1）**暂停一个周期或多个周期**，直到数据相关问题消失后再执行。可分为**硬件阻塞(stall)**和**软件插入“NOP”指令**两种方法。

（2）**设置相关专用通路**，即不等前一条指令把结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令ALU计算结果作为自己输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这也称为**数据旁路技术**。

（3）**调整指令顺序**。



3. **控制相关(控制冲突)**

当流水线遇到**转移指令**和**其它改变PC值的指令**而造成断流时，会引起控制相关。解决方法如下：

（1）**对转移指令进行分支预测，尽早生成转移目标地址**。分支预测分**简单(静态)预测**和**动态预测**。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态调整，有较高的预测准确率。

（2）预测转移成功和不转移成功两个控制流方向上的目标指令。

（3）加快和提前形成条件码。

（4）提高转移方向的猜准率。



## 第6章 总线

### 6.1 总线概述

#### 6.1.1 总线基本概念

1. **总线的定义**

总线是一组能为多个部件分时共享的公共信息传送线路。**分时**和**共享**是总线的两个特征。

- **分时**：同一时刻只允许有一个部件向总线发送信息。
- **共享**：总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。

2. **总线设备**

- **主设备**：总线的主设备是指获得总线控制权的设备。
- **从设备**：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。

3. **总线特性**

- **机械特征**：尺寸、形状
- **电气特性**：传输方向和有效的电平范围
- **功能特性**：每根传输线的功能
- **时间特性**：信号和时序的关系

4. **总线的猝发式传输方式**

在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为**猝发传送**。



#### 6.1.4 总线的性能指标

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-20</font>

（1）**总线的传输周期**：指一次总线操作所需的时间(包括**申请阶段**、**寻址阶段**、**传输阶段**和**结束阶段**)，简称**总线周期**。总线传输周期通常由若干**总线时钟周期**构成。

（2）**总线时钟周期**：即**机器的时钟周期**。机器有一个统一的时钟，以控制整个计算机各个部件，总线也要受此时钟的控制。

（3）**总线的工作频率**：总线上各种操作的频率，为**总线周期的倒数**。实际上指1s内传送几次数据。若
$$
总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
$$
（4）**总线的时钟频率**：即**机器的时钟频率**，它为**时钟周期的倒数**。

（5）**总线宽度**：又称**总线位宽**，它是总线上同时能传输的数据位数，通常指数据总线的根数，如32根称为32位总线。

（6）**总线的带宽**：可以理解为**总线的数据传输率**，即单位时间内总线上可以传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用**字节/秒(B/s)**。
$$
总线带宽=总线工作频率 \times (总线宽度/8)
$$
（7）**总线复用**：总线复用指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。

（8）**信号线数**：**地址总线**、**数据总线**和**控制总线**3种总线数的总和称为信号线数。其中，总线的最主要性能指标为**总线宽度**、**总线(工作)频率**、**总线带宽**。



### 6.4 总线标准

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-20</font>

#### 6.4.1 常见的总线标准

&emsp;&emsp;总线的标准有**ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB**等。它们主要的区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。

<img src="C:\Users\HP\Desktop\组成原理\6.4.1-1.png" alt="6.4.1-1" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\6.4.1-2.png" alt="6.4.1-2" style="zoom:80%;" />



## 第7章 输入/输出系统



### 7.2 外部设备

&emsp;&emsp;外部设备也称为外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有**键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器**等。

#### 7.2.1 输入设备

1. **键盘**

&emsp;&emsp;键盘是最常用的输入设备，通过它可以=发出命令或输入数据。

&emsp;&emsp;键盘输入信息可分为3个步骤：① 查出按下哪个键；② 将该键翻译成能被主机接收的编码，如ASCII码；③ 将编码传送给主机。

2. **鼠标**

&emsp;&emsp;鼠标是常用的定位输入设备，它分**机械式**和**光电式**两种。

&emsp;&emsp;工作原理：鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。

#### 7.2.2 输出设备

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-22</font>

1. **显示器**

- **分类**

**（1）按显示设备所用的显示器件分类**：阴极射线管(CRT)显示器、液晶显示器(LCD)、发光二极管(LED)显示器等。

**（2）按所显示的信息内容分类**：字符显示器、图形显示器、图像显示器。

**（3）按扫描方式不同**：光栅扫描显示器、随机扫描显示器。

- **屏幕大小**：以对角线的长度表示，常用的有12~29英寸等。
- **分辨率**：所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素乘积表示，如800&times;600、1027&times;768等。
- **灰度级**：灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，**灰度级越多，图像的层次越清楚、逼真**，典型的有8位(256级)、16位等。
- **刷新**：光点只能保持极短的时间就会消失，此时必须在光点消失前重新扫描显示一遍，这个过程称为刷新。
- **刷新频率**：指单位时间内扫描整个屏幕内容的次数。按照**人的视觉生理，刷新频率大于30HZ时才不会感到闪烁**，通常显示器的刷新频率为60~120HZ。
- **显示存储器(VRAM)**：也称为刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其**存储容量由图像分辨率和灰度级决定的**，分辨率越高，灰度级越多，刷新存储容量越大。

$$
\begin{aligned}
& VRAM容量 = 分辨率 \times 灰度级位数 \\
& VRAM带宽 = 分辨率 \times 灰度级位数 \times 帧数
\end{aligned}
$$

- **液晶(LCD)显示器 VS 发光二极管(LED)显示器**

LED显示器在亮度、功耗、可视角度和刷新速率等方面更具优势。

2. **打印机**

- **分类**

**（1）按工作原理**：打击式和非打击式打印机

**（2）按工作方式**：点阵打印机、针式打印机、喷墨式打印机、激光打印机



### 7.3 I/O接口

I/O接口(I/O)控制器是**主机和外设之间的交接界面**，通过接口可以实现主机和外设之间的信息交换。

#### 7.3.1 I/O接口的功能

**（1）实现主机和外设的通信联络控制**：解决主机与外设时序的配合问题，协调不同工作速度的外设和主机之间的交换信息。

**（2）进行地址译码和设备选择**：CPU送来外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机与指定的外设交换信息。

（3）**实现数据缓冲**：CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，避免因速度不一致而丢失数据。

（4）**信号格式的转换**：电平转换、并/串或串/并转换、模/数或数/模转换等。

（5）**传送控制命令和状态信息**：CPU要启动某一外设时，通过接口中的**命令寄存器**向外设发送启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的**状态寄存器**，并反馈给CPU。外设向CPU提出中断请求和DMA请求时，CPU也应有相应的响应信号反馈给外设。

#### 7.3.2 I/O接口的基本结构

<img src="C:\Users\HP\Desktop\组成原理\7.3.2-1.png" alt="7.3.2-1" style="zoom:85%;" />

- **内部接口**：内部接口与系统总线相连，实际上是**内存、CPU**相连。数据的传输方式只能是**并行传输**。
- **外部接口**：外部接口通过接口电缆与外设相连，外部接口的数据传输只能是**串行方式**。

I/O接口与CPU之间的I/O总线有**数据线**、**命令线**和**地址线**。

- **命令线**和**地址线**都是**单向传输**的，从CPU传送给I/O接口，而**I/O接口中的命令字**、**状态字**及**中断类型号**均是I/O接口发往CPU的，故只能通过**I/O总线的数据线**传输。

【注】**接口和端口是两个不同的概念**。端口是指接口电路中可以进行**读/写的寄存器**，若干端口加上相应的控制逻辑才可以组成接口。



### 7.4 I/O方式



#### 7.4.2 程序中断方式



2. **程序中断方式工作流程**

**（1）中断请求**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-22</font>

中断请求是中断源向CPU发出中断请求信号。

① **内中断** VS **外中断**

- **外中断**：指来自处理器和内存以外的部件引起的中断，包括**I/O设备发出的I/O中断**、**外部信号中断(Esc建)**，以及各种定时器引起的时钟中断等。
- **内中断**：指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断及用户态到核心态的切换等。

② **硬件中断** VS **软件中断**

- **硬件中断**：通过外部的硬件产生的中断。**硬件中断属于外中断**。
- **软件中断**：通过某条指令产生的中断，这种中断可以编程实现。**软件中断是内中断**。

③ **非屏蔽中断** VS **可屏蔽中断**

- **非屏蔽中断**：**非屏蔽中断是一种硬件中断**，这种中断通过不可中断请求NMI控制，不受中断标志位IF的影响，即使在关中断(IF = 0)的情况下也会被响应。
- **屏蔽中断**：**可屏蔽中断也是一种硬件中断**，此种中断通过中断请求标记触发器INTR控制，且受中断标志位IF的影响，在关中断情况下不接受中断请求。

也就是说，**可屏蔽中断和非屏蔽中断均是外部中断**。



**（4）中断隐指令**

&emsp;&emsp;CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由**硬件直接实现**的，将它称为中断隐指令。

&emsp;&emsp;中断隐指令并不是指令系统中一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下

①**关中断**：在中断服务程序中，为了保护中断现场(即CPU主要寄存器中的内容)期间不被新的中断所打断，必须关中断。

②**保存断点**：为保证在中断服务程序执行完毕后能正确返回到原来的程序，必须将原来的断点(即**程序计数器PC的内容**)保存起来。

③**引出中断服务程序**：引出中断服务程序的实质是，取出中断服务程序的入口地址并传送给程序计数器(PC)。



6. **中断处理过程**

- **允许嵌套中断的处理流程**

![7.4.2-1](C:\Users\HP\Desktop\组成原理\7.4.2-1.png)

- **不允许嵌套中断的处理流程**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-21</font>

1）关中断 -> 2）保存断点 -> 3）识别中断源 -> 4）保护现场 -> 5）中断处理事件 -> 6）恢复现场 -> 7）开中断 -> 8）中断返回

**【注】**不允许嵌套中断的处理流程中**少了在恢复现场过程中的关中断和开中断**。

