## 第2章 数据的表示与运算



### 2.2 定点数的表示与运算

#### 2.2.3 强制类型转换

1. **有符号$\rightarrow$无符号**

```c
int main() {
    short x = -4321;
    unsigned short y = (unsigned short)x;
    printf("x=%d, y=%u\n",x,y);
}
```

![2-2-1](C:\Users\HP\Desktop\组成原理\2-2-1.png)

其中，$x$为补码表示，$y$为无符号真值。

2. **无符号$\rightarrow$有符号**

```C
int main() {
    unsigned short x = 65535;
    short y = (short)x;
    printf("x=%u, y=%d\n",x,y);
}
```

在采用补码的机器上，$x=65535, y=-1$

3. **大字长$\rightarrow$小字长**

```C
int main() {
 	int x = 165537, u = -34991;			//int型占用4B
    short y = (short)x, v = (short)u;	//short占用2B
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

>$x = 165537, y = -31071$
>
>$u=-34991, v = 30545$

其中$x,y,u,v$的16进制表示分别为0x000286a1，0x86a1，0xffff7751，0x7751。

**原则总结：**当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

4. **小字长$\rightarrow$大字长**

```c
int main() {
 	short x = -4321;
    int y = x;
    unsigned short u = (unsigned short)x;
    unsigned int v = u;
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

> $x = -4321, y = -4321$
>
> $u=61215, v = 61215$

其中$x,y,u,v$的16进制表示分别为0xef1f，0xffffef1f，0xef1f，0x0000ef1f

**原则总结：**当小字长变量向大字长变量强制类型转换时，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。



### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

1. **浮点数的表示格式**

&emsp;&emsp;通常，浮点数表示为
$$
N=r^E \times M
$$
其中，$r$是浮点数的阶码的底，与尾数的基数相同，通常$r=2$。$E$为阶码，$M$为尾数。

![2.3.1-1](C:\Users\HP\Desktop\组成原理\2.3.1-1.png)

&emsp;&emsp;阶码是整数，**阶符$J_f$和阶码的位数$m$共同反映浮点数的表示范围及小数点的实际位置**。数符$S_f$代表浮点数的符号，**尾数的位数$n$反映浮点数的精度**。

2. **规格化浮点数**

- **左规**：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数左移一位，阶码减1(基数为2时)。**左规可能要进行多次**。
- **右规**：当浮点数运算的结果尾数出现溢出(双符号为01或10)时，将尾数算术右移一位、阶码加1(基数为2时)。**需要右规时，只需要进行一次**。

规格化浮点数的尾数$M$应满足条件$1/r \le |M| \le 1$。

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-2.png" alt="2.3.1-2" style="zoom:85%;" />

**【注】**

- 当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定为1，补码规格化数的尾数最高位一定与尾数符号位相反。
- 当浮点数尾数的基数为4时，原码规格化形式的尾数最高两位不全为0。
- 当浮点数尾数的基数为8时，原码规格化形式的尾数最高三位不全为0。

4. **IEEE 754 标准**

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-3.png" alt="2.3.1-3" style="zoom:85%;" />

&emsp;&emsp;IEEE 754 标准规定了常用的浮点格式有短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-4.png" alt="2.3.1-4" style="zoom:80%;" />

【注】**短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位数。临时浮点数又称扩展精度浮点数，无隐含位**。

> 例如，$(12)_{10}=(1100)_2$，将它规格化后结果为$1.1 \times 2^3$，其中整数部分“1”将不存储在23位尾数内。

&emsp;&emsp;IEEE 754标准中，规格化的短浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-127}
$$

#### 2.3.2 浮点数的加减运算

&emsp;&emsp;浮点数运算特点是**阶码运算和尾数运算分开进行**，浮点数的**加减运算一律采用补码**。浮点数的加减运算分以下几步：

1. **对阶**

**小阶向大阶对齐原则**：阶码小的尾数右移一位(基数为2)，阶加1，直到两个数的阶码相等为止。

2. **尾数求和**

将对阶后的尾数按定点数加减运算规则运算。

3. **规格化**

以双符号为例，当尾数大于0时，其补码规格化形式为
$$
[S]_{补}=00.1**
$$
当尾数小于0时，其补码规格化形式为
$$
[S]_{补}=11.0**
$$
可见，当尾数的最高位数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种：

**1）左规**：当尾数出现00.0&times;&times;&times;或11.1&times;&times;&times;时，需左规，即尾数左移1位，和的阶码减1，知道尾数为00.1&times;&times;&times;或11.0&times;&times;&times;。

**2）右规**：当尾数求和结果溢出(如尾数为10.&times;&times;&times;或01.&times;&times;&times;时，需右规，即尾数右移一位，和的阶码加1。

**【注】**

- 左规相当于乘2，右规相当于除2。
- $[-1/2]_{补}=1.1000$不是规格化数，需要左规一次，$[-1]_{补}=1.0000$才是规格化数。

4. **舍入**

在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。

**1）“0”舍“1”入法**：在尾数右移时，被移去的最高位为0时，则舍去；被移去的最高数值位为1时，则在尾数的末位加1。这样做可能使尾数又溢出，此时需要再做一次右规。

**2）恒置“1”法**：尾数右移时，不论丢掉的最高位数值位是“1”还是"0"，都使右移后的尾数末位恒置"1"。

5. **溢出判断**

- 当尾数出现10.&times;&times;&times;或01.&times;&times;&times;时，并不表示溢出，只能将此数右规后，再根据阶码来判断运算结果是否溢出。
- 浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例子，当阶码的符号位出现“01”时，即**阶码大于最大阶码时**，表示**上溢**。当阶码的符号位出现“10”时，即**阶码小于最小阶码时**，表示**下溢**。



## 第3章 存储系统

### 3.3 半导体随机存储器

#### 3.3.2 SRAM和DRAM

<img src="C:\Users\HP\Desktop\组成原理\3.3.2-1.png" alt="3.3.2-1" style="zoom:90%;" />

#### 3.3.3 只读存储器ROM

1. **只读存储器的特点**

ROM和RAM都是支持**随机存取**的存储器，其中SRAM和DRAM均为易失性存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电了也不会丢失，它在计算机系统中只供读出的存储器。

​		1）**结构简单**，位密度比可读可写存储器的高。

​		2）具有**非易失性**，所以可靠性高。

2. **ROM的类型**

   1）掩膜式只读存储器MROM

   2）一次可编程只读存储器PROM

   3）可擦除可编程只读存储器EPROM

   4）闪速存储器(Flash Memory)

   5）固态硬盘(Solid State Driver，SSD)





### 3.4 主存储器与CPU的连接

#### 3.4.2 主存容量的扩展

1. **位扩展(并联)**

&emsp;&emsp;位扩展是使存储芯片的数据位数与CPU的数据线数相等。如图，用8片8K&times;1位的RAM芯片组成8K&times;8位的存储器。8位RAM芯片的地址线$A_{12}$~$A_0$、片选信号$\overline{CS}$、读写控制线$\overline{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。

![3.4.2-1](C:\Users\HP\Desktop\组成原理\3.4.2-1.png)

2. **字扩展(串联)**

&emsp;&emsp;字扩展是指增加存储器中字的数量，而位数不变。如图，用4片16K&times;8位的RAM芯片组成64K&times;8位的存储器。4片RAM芯片的数据线$D_0$~$D_7$和读写控制线$\overline{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}=00$时，译码输出端0有效，选最左边的1号芯片；$A_{15}A_{14}=01$时，译码输出端1有效，选中2号芯片，以此类推(在同一时间内只能有一个芯片被选中)

<img src="C:\Users\HP\Desktop\组成原理\3.4.2-2.png" alt="3.4.1-2" style="zoom:85%;" />

![3.4.1-3](C:\Users\HP\Desktop\组成原理\3.4.2-3.png)

3. **字位同时扩展法**

&emsp;&emsp;字位同时扩展既增加了存储字的数量，又增加了存储字长。如图，用用8片16K&times;4位的RAM芯片组成64K&times;8位的存储器。每两片构成一组16K&times;8位的存储器**(位扩展)**，4组便构成64K&times;8位**(字扩展)**。

![3.4.2-4](C:\Users\HP\Desktop\组成原理\3.4.2-4.png)



### 3.6 高速缓冲存储器Cache

#### 3.6.1 程序访问的局部性原理

- **时间局部性**：最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序存在循环。
- **空间局部性**：最近的未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的。数据一般也是以向量、数组、表等形式簇聚第存储在一起的。

高速缓冲技术就是利用程序访问的局部性原理。



#### 3.6.3 Cache和主存的映射方式

1. **直接映射**

- **映象规则**：主存中一块只能映象到Cache特定的一块中。

- Cache地址**计算公式**：

$$
b=B \ \text{mod} \ C_b
$$

其中，$b$是Cache的块号(又称Cache的行号)，$B$是主存的块号，$C_b$是Cache中的总块数。

- **地址结构**：

![3.6.3-1](C:\Users\HP\Desktop\组成原理\3.6.3-1.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-2.png" alt="3.6.3-2" style="zoom: 67%;" />

2. **全相联映射**

- **映象规则**：主存的任意一块可以映象到Cache中的任意一块。

- **地址结构**

  ![3.6.3-5](C:\Users\HP\Desktop\组成原理\3.6.3-5.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-3.png" alt="3.6.3-3" style="zoom: 67%;" />

3. **组相联映射**

- **映象规则**
  - 主存和Cache按同样大小划分成块和组
  - 主存和Cache组之间采用直接映象方式
  - 在两个对应的组内采用全相联映象方式

- **地址结构**

![3.6.3-6](C:\Users\HP\Desktop\组成原理\3.6.3-6.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-7.png" alt="3.6.3-7" style="zoom: 67%;" />



### 3.7 虚拟存储器

#### 3.7.5 快表(TLB)

&emsp;&emsp;在页式或段式或段页式虚拟存储器中必须先去一次主存查页表或段表才取得数据。快表利用了**局部性原则**。快表存放在**高速缓冲器**中，**慢表(Page)**存放在**内存**中。快表只是慢表的一个副本，而且只存放了慢表中很少的一部分。

**【注1】**TLB是Page的一个很小副本，所以若TLB命中则Page一定命中。

**【注2】**在同时具有虚拟页式存储器(有TLB)和Cache的系统中，访问的顺序为：**TLB$\rightarrow$页表$\rightarrow$Cache$\rightarrow$主存**。CPU发出访存命令(逻辑地址)，先查找TLB和Page，将逻辑地址转换为物理地址，再查找相应的Cache块(与主存查找并行)。

**【注3】**若Cache命中，则说明所需页面已调入主存，Page必然命中，但TLB不一定命中；若Cache不命中，则并不能说明所需的页面未调入主存，和TLB和Page命中与否没有关系；若Page不命中，则说明所需页面未调入主存，当然Cache和主存也不会命中，执行调页策略。



## 第4章：指令系统





### 4.2 指令寻址方式

&emsp;&emsp;寻址方式是指寻找指令或操作数有效地址，即确定本条指令的数据地址及下一条待执行指令的地址的方法。

**【注1】A：形式地址**	**EA：有效地址**

**【注2】**\(A\)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应(A)就是寄存器中的数值，或相应内存单元的数值。

**【注3】**EA=(A)意思是有效地址是地址A中的值。

#### 4.2.1 指令寻址和数据寻址

&emsp;&emsp;寻址方式分为指令寻址和数据寻址两大类。寻找下一条要执行的指令地址称为**指令寻址**；寻找操作数的地址称为**数据寻址**。

1. **指令寻址**

   **1）顺序寻址**：通过程序计数器(PC)加1(1个指令字长)，自动形成下一条指令的地址。

   **2）跳跃寻址：**所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条下条指令地址的计算方式。

   【注】是否跳跃可能受到**状态寄存器**和**操作数**的控制，而跳跃到的地址分为**绝对地址**(由标记符直接得到)和**相对地址**(相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以**下一条指令仍然通过程序计数器(PC)给出**。

2. **数据寻址**

&emsp;&emsp;数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。

![4.2.1-1](C:\Users\HP\Desktop\组成原理\4.2.1-1.png)





### 4.3 CISC和RISC的基本概念

#### 4.3.2 精简指令系统计算机(RISC)

<img src="C:\Users\HP\Desktop\组成原理\4-3-1.png" alt="4-3-1" style="zoom:80%;" />

#### 4.3.3 CISC和RISC的比较

<img src="C:\Users\HP\Desktop\组成原理\4-3-2.png" alt="4-3-2" style="zoom:80%;" />



## 第5章 中央处理器

### 5.1 CPU的功能和基本结构

#### 5.1.1 CPU的功能

- 指令控制
- 操作控制
- 时间控制
- 数据加工
- 中断处理

#### 5.1.2 CPU的基本结构部

（1）运算器





（2）控制器



### 5.2 指令的执行过程

#### 5.2.1 指令周期

1. **概念**

&emsp;&emsp;CPU从主存中每取出并执行一条指令所需的全部时间称为**指令周期**，即CPU完成一条指令的时间。

&emsp;&emsp;指令周期常用若干个**机器周期**来表示，一个机器周期又包含若干**时钟周期**(也称为**节拍**或**T周期**，它是CPU操作的最基本单位)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。
$$
\begin{align}
机器周期 &= 主存周期 \\
时钟周期 &= 计算机主频的倒数 \\
计算机主频 &= 1s时钟周期数
\end{align}
$$

<img src="C:\Users\HP\Desktop\组成原理\5.2.1-1.png" alt="5.2.1-1" style="zoom:95%;" />



![5.2.1-2](C:\Users\HP\Desktop\组成原理\5.2.1-2.png)





### 5.3 数据通路的功能和基本结构



### 5.4 控制器的功能和工作原理

<img src="C:\Users\HP\Desktop\组成原理\5.4-1.png" style="zoom:75%;" />

### 5.5 指令流水线



## 第6章 总线

### 6.1 总线概述

#### 6.1.1 总线基本概念

1. **总线的定义**

总线是一组能为多个部件分时共享的公共信息传送线路。**分时**和**共享**是总线的两个特征。

- **分时**：同一时刻只允许有一个部件向总线发送信息。
- **共享**：总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。

2. **总线设备**

- **主设备**：总线的主设备是指获得总线控制权的设备。
- **从设备**：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。

3. **总线特性**

- **机械特征**：尺寸、形状
- **电气特性**：传输方向和有效的电平范围
- **功能特性**：每根传输线的功能
- **时间特性**：信号和时序的关系

4. **总线的猝发式传输方式**

在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为**猝发传送**。



#### 6.1.4 总线的性能指标

（1）**总线的传输周期**：指一次总线操作所需的时间(包括**申请阶段**、**寻址阶段**、**传输阶段**和**结束阶段**)，简称**总线周期**。总线传输周期通常由若干**总线时钟周期**构成。

（2）**总线时钟周期**：即**机器的时钟周期**。机器有一个统一的时钟，以控制整个计算机各个部件，总线也要受此时钟的控制。

（3）**总线的工作频率**：总线上各种操作的频率，为**总线周期的倒数**。实际上指1s内传送几次数据。若
$$
总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
$$
（4）**总线的时钟频率**：即**机器的时钟频率**，它为**时钟周期的倒数**。

（5）**总线宽度**：又称**总线位宽**，它是总线上同时能传输的数据位数，通常指数据总线的根数，如32根称为32位总线。

（6）**总线的带宽**：可以理解为**总线的数据传输率**，即单位时间内总线上可以传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用**字节/秒(B/s)**。
$$
总线带宽=总线工作频率 \times (总线宽度/8)
$$
（7）**总线复用**：总线复用指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。

（8）**信号线数**：**地址总线**、**数据总线**和**控制总线**3种总线数的总和称为信号线数。其中，总线的最主要性能指标为**总线宽度**、**总线(工作)频率**、**总线带宽**。







## 第7章 输入/输出系统



### 7.3 I/O接口

I/O接口(I/O)控制器是**主机和外设之间的交接界面**，通过接口可以实现主机和外设之间的信息交换。

#### 7.3.1 I/O接口的功能

**（1）实现主机和外设的通信联络控制**：解决主机与外设时序的配合问题，协调不同工作速度的外设和主机之间的交换信息。

**（2）进行地址译码和设备选择**：CPU送来外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机与指定的外设交换信息。

（3）**实现数据缓冲**：CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，避免因速度不一致而丢失数据。

（4）**信号格式的转换**：电平转换、并/串或串/并转换、模/数或数/模转换等。

（5）**传送控制命令和状态信息**：CPU要启动某一外设时，通过接口中的**命令寄存器**向外设发送启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的**状态寄存器**，并反馈给CPU。外设向CPU提出中断请求和DMA请求时，CPU也应有相应的响应信号反馈给外设。

#### 7.3.2 I/O接口的基本结构

<img src="C:\Users\HP\Desktop\组成原理\7.3.2-1.png" alt="7.3.2-1" style="zoom:85%;" />

- **内部接口**：内部接口与系统总线相连，实际上是**内存、CPU**相连。数据的传输方式只能是**并行传输**。
- **外部接口**：外部接口通过接口电缆与外设相连，外部接口的数据传输只能是**串行方式**。

I/O接口与CPU之间的I/O总线有**数据线**、**命令线**和**地址线**。

- **命令线**和**地址线**都是**单向传输**的，从CPU传送给I/O接口，而**I/O接口中的命令字**、**状态字**及**中断类型号**均是I/O接口发往CPU的，故只能通过**I/O总线的数据线**传输。

【注】**接口和端口是两个不同的概念**。端口是指接口电路中可以进行**读/写的寄存器**，若干端口加上相应的控制逻辑才可以组成接口。



### 7.4 I/O方式



#### 7.4.2 程序中断方式



2. 程序中断方式工作流程



**（4）中断隐指令**

2012选

&emsp;&emsp;CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由**硬件直接实现**的，将它称为中断隐指令。

&emsp;&emsp;中断隐指令并不是指令系统中一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下

①**关中断**：在中断服务程序中，为了保护中断现场(即CPU主要寄存器中的内容)期间不被新的中断所打断，必须关中断。

②**保存断点**：为保证在中断服务程序执行完毕后能正确返回到原来的程序，必须将原来的断点(即**程序计数器PC的内容**)保存起来。

③**引出中断服务程序**：引出中断服务程序的实质是，取出中断服务程序的入口地址并传送给程序计数器(PC)。



6. **中断处理过程**

- **允许嵌套中断的处理流程**

![7.4.2-1](C:\Users\HP\Desktop\组成原理\7.4.2-1.png)

- **不允许嵌套中断的处理流程**

1）关中断 -> 2）保存断点 -> 3）识别中断源 -> 4）保护现场 -> 5）中断处理事件 -> 6）恢复现场 -> 7）开中断 -> 8）中断返回



