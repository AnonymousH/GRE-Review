## 第2章 数据的表示与运算



### 2.2 定点数的表示与运算

#### 2.2.3 强制类型转换

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-12</font>

1. **有符号$\rightarrow$无符号**

```c
int main() {
    short x = -4321;
    unsigned short y = (unsigned short)x;
    printf("x=%d, y=%u\n",x,y);
}
```

![2-2-1](C:\Users\HP\Desktop\组成原理\2-2-1.png)

其中，$x$为补码表示，$y$为无符号真值。

2. **无符号$\rightarrow$有符号**

```C
int main() {
    unsigned short x = 65535;
    short y = (short)x;
    printf("x=%u, y=%d\n",x,y);
}
```

在采用补码的机器上，$x=65535, y=-1$

3. **大字长$\rightarrow$小字长**

```C
int main() {
 	int x = 165537, u = -34991;			//int型占用4B
    short y = (short)x, v = (short)u;	//short占用2B
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

>$x = 165537, y = -31071$
>
>$u=-34991, v = 30545$

其中$x,y,u,v$的16进制表示分别为0x000286a1，0x86a1，0xffff7751，0x7751。

**原则总结：**当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

4. **小字长$\rightarrow$大字长**

```c
int main() {
 	short x = -4321;
    int y = x;
    unsigned short u = (unsigned short)x;
    unsigned int v = u;
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

> $x = -4321, y = -4321$
>
> $u=61215, v = 61215$

其中$x,y,u,v$的16进制表示分别为0xef1f，0xffffef1f，0xef1f，0x0000ef1f

**原则总结：**当小字长变量向大字长变量强制类型转换时，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。



### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

1. **浮点数的表示格式**

&emsp;&emsp;通常，浮点数表示为
$$
N=r^E \times M
$$
其中，$r$是浮点数的阶码的底，与尾数的基数相同，通常$r=2$。$E$为阶码，$M$为尾数。

![2.3.1-1](C:\Users\HP\Desktop\组成原理\2.3.1-1.png)

&emsp;&emsp;阶码是整数，**阶符$J_f$和阶码的位数$m$共同反映浮点数的表示范围及小数点的实际位置**。数符$S_f$代表浮点数的符号，**尾数的位数$n$反映浮点数的精度**。

2. **规格化浮点数**

- **左规**：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数左移一位，阶码减1(基数为2时)。**左规可能要进行多次**。
- **右规**：当浮点数运算的结果尾数出现溢出(双符号为01或10)时，将尾数算术右移一位、阶码加1(基数为2时)。**需要右规时，只需要进行一次**。

规格化浮点数的尾数$M$应满足条件$1/r \le |M| \le 1$。

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-2.png" alt="2.3.1-2" style="zoom:85%;" />

**【注】**

- 当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定为1，补码规格化数的尾数最高位一定与尾数符号位相反。
- 当浮点数尾数的基数为4时，原码规格化形式的尾数最高两位不全为0。
- 当浮点数尾数的基数为8时，原码规格化形式的尾数最高三位不全为0。

4. **IEEE 754 标准**

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-3.png" alt="2.3.1-3" style="zoom:85%;" />

&emsp;&emsp;IEEE 754 标准规定了常用的浮点格式有短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-4.png" alt="2.3.1-4" style="zoom:80%;" />

【注】**短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位数。临时浮点数又称扩展精度浮点数，无隐含位**。

> 例如，$(12)_{10}=(1100)_2$，将它规格化后结果为$1.1 \times 2^3$，其中整数部分“1”将不存储在23位尾数内。

&emsp;&emsp;IEEE 754标准中，规格化的短浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-127}
$$

#### 2.3.2 浮点数的加减运算

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-13</font>

&emsp;&emsp;浮点数运算特点是**阶码运算和尾数运算分开进行**，浮点数的**加减运算一律采用补码**。浮点数的加减运算分以下几步：

1. **对阶**

**小阶向大阶对齐原则**：阶码小的尾数右移一位(基数为2)，阶加1，直到两个数的阶码相等为止。

2. **尾数求和**

将对阶后的尾数按定点数加减运算规则运算。

3. **规格化**

以双符号为例，当尾数大于0时，其补码规格化形式为
$$
[S]_{补}=00.1**
$$
当尾数小于0时，其补码规格化形式为
$$
[S]_{补}=11.0**
$$
可见，当尾数的最高位数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种：

**1）左规**：当尾数出现00.0&times;&times;&times;或11.1&times;&times;&times;时，需左规，即尾数左移1位，和的阶码减1，知道尾数为00.1&times;&times;&times;或11.0&times;&times;&times;。

**2）右规**：当尾数求和结果溢出(如尾数为10.&times;&times;&times;或01.&times;&times;&times;时，需右规，即尾数右移一位，和的阶码加1。

**【注】**

- 左规相当于乘2，右规相当于除2。
- $[-1/2]_{补}=1.1000$不是规格化数，需要左规一次，$[-1]_{补}=1.0000$才是规格化数。

4. **舍入**

在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。

**1）“0”舍“1”入法**：在尾数右移时，被移去的最高位为0时，则舍去；被移去的最高数值位为1时，则在尾数的末位加1。这样做可能使尾数又溢出，此时需要再做一次右规。

**2）恒置“1”法**：尾数右移时，不论丢掉的最高位数值位是“1”还是"0"，都使右移后的尾数末位恒置"1"。

5. **溢出判断**

- 当尾数出现10.&times;&times;&times;或01.&times;&times;&times;时，并不表示溢出，只能将此数右规后，再根据阶码来判断运算结果是否溢出。
- 浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例子，当阶码的符号位出现“01”时，即**阶码大于最大阶码时**，表示**上溢**。当阶码的符号位出现“10”时，即**阶码小于最小阶码时**，表示**下溢**。



## 第3章 存储系统

### 3.3 半导体随机存储器

#### 3.3.2 SRAM和DRAM

<img src="C:\Users\HP\Desktop\组成原理\3.3.2-1.png" alt="3.3.2-1" style="zoom:90%;" />

#### 3.3.3 只读存储器ROM

1. **只读存储器的特点**

ROM和RAM都是支持**随机存取**的存储器，其中SRAM和DRAM均为易失性存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电了也不会丢失，它在计算机系统中只供读出的存储器。

​		1）**结构简单**，位密度比可读可写存储器的高。

​		2）具有**非易失性**，所以可靠性高。

2. **ROM的类型**

   1）掩膜式只读存储器MROM

   2）一次可编程只读存储器PROM

   3）可擦除可编程只读存储器EPROM

   4）闪速存储器(Flash Memory)

   5）固态硬盘(Solid State Driver，SSD)





### 3.4 主存储器与CPU的连接

#### 3.4.2 主存容量的扩展

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-15</font>

1. **位扩展(并联)**

&emsp;&emsp;位扩展是使存储芯片的数据位数与CPU的数据线数相等。如图，用8片8K&times;1位的RAM芯片组成8K&times;8位的存储器。8位RAM芯片的地址线$A_{12}$~$A_0$、片选信号$\overline{CS}$、读写控制线$\overline{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。

![3.4.2-1](C:\Users\HP\Desktop\组成原理\3.4.2-1.png)

2. **字扩展(串联)**

&emsp;&emsp;字扩展是指增加存储器中字的数量，而位数不变。如图，用4片16K&times;8位的RAM芯片组成64K&times;8位的存储器。4片RAM芯片的数据线$D_0$~$D_7$和读写控制线$\overline{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}=00$时，译码输出端0有效，选最左边的1号芯片；$A_{15}A_{14}=01$时，译码输出端1有效，选中2号芯片，以此类推(在同一时间内只能有一个芯片被选中)

<img src="C:\Users\HP\Desktop\组成原理\3.4.2-2.png" alt="3.4.1-2" style="zoom:85%;" />

![3.4.1-3](C:\Users\HP\Desktop\组成原理\3.4.2-3.png)

3. **字位同时扩展法**

&emsp;&emsp;字位同时扩展既增加了存储字的数量，又增加了存储字长。如图，用用8片16K&times;4位的RAM芯片组成64K&times;8位的存储器。每两片构成一组16K&times;8位的存储器**(位扩展)**，4组便构成64K&times;8位**(字扩展)**。

![3.4.2-4](C:\Users\HP\Desktop\组成原理\3.4.2-4.png)



### 3.6 高速缓冲存储器Cache

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-21</font>

#### 3.6.1 程序访问的局部性原理

- **时间局部性**：最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序存在循环。
- **空间局部性**：最近的未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的。数据一般也是以向量、数组、表等形式簇聚第存储在一起的。

高速缓冲技术就是利用程序访问的局部性原理。



#### 3.6.3 Cache和主存的映射方式

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-14</font>

1. **直接映射**

- **映象规则**：主存中一块只能映象到Cache特定的一块中。

- Cache地址**计算公式**：

$$
b=B \ \text{mod} \ C_b
$$

其中，$b$是Cache的块号(又称Cache的行号)，$B$是主存的块号，$C_b$是Cache中的总块数。

- **地址结构**：

![3.6.3-1](C:\Users\HP\Desktop\组成原理\3.6.3-1.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-2.png" alt="3.6.3-2" style="zoom: 67%;" />

2. **全相联映射**

- **映象规则**：主存的任意一块可以映象到Cache中的任意一块。

- **地址结构**

  ![3.6.3-5](C:\Users\HP\Desktop\组成原理\3.6.3-5.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-3.png" alt="3.6.3-3" style="zoom: 67%;" />

3. **组相联映射**

- **映象规则**
  - 主存和Cache按同样大小划分成块和组
  - 主存和Cache组之间采用直接映象方式
  - 在两个对应的组内采用全相联映象方式

- **地址结构**

![3.6.3-6](C:\Users\HP\Desktop\组成原理\3.6.3-6.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-7.png" alt="3.6.3-7" style="zoom: 67%;" />



### 3.7 虚拟存储器

#### 3.7.5 快表(TLB)

&emsp;&emsp;在页式或段式或段页式虚拟存储器中必须先去一次主存查页表或段表才取得数据。快表利用了**局部性原则**。快表存放在**高速缓冲器**中，**慢表(Page)**存放在**内存**中。快表只是慢表的一个副本，而且只存放了慢表中很少的一部分。

**【注1】**TLB是Page的一个很小副本，所以若TLB命中则Page一定命中。

**【注2】**在同时具有虚拟页式存储器(有TLB)和Cache的系统中，访问的顺序为：**TLB$\rightarrow$页表$\rightarrow$Cache$\rightarrow$主存**。CPU发出访存命令(逻辑地址)，先查找TLB和Page，将逻辑地址转换为物理地址，再查找相应的Cache块(与主存查找并行)。

**【注3】**若Cache命中，则说明所需页面已调入主存，Page必然命中，但TLB不一定命中；若Cache不命中，则并不能说明所需的页面未调入主存，和TLB和Page命中与否没有关系；若Page不命中，则说明所需页面未调入主存，当然Cache和主存也不会命中，执行调页策略。



## 第4章：指令系统





### 4.2 指令寻址方式

&emsp;&emsp;寻址方式是指寻找指令或操作数有效地址，即确定本条指令的数据地址及下一条待执行指令的地址的方法。

**【注1】A：形式地址**	**EA：有效地址**

**【注2】**\(A\)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应(A)就是寄存器中的数值，或相应内存单元的数值。

**【注3】**EA=(A)意思是有效地址是地址A中的值。

#### 4.2.1 指令寻址和数据寻址

&emsp;&emsp;寻址方式分为指令寻址和数据寻址两大类。寻找下一条要执行的指令地址称为**指令寻址**；寻找操作数的地址称为**数据寻址**。

1. **指令寻址**

   **1）顺序寻址**：通过程序计数器(PC)加1(1个指令字长)，自动形成下一条指令的地址。

   **2）跳跃寻址：**所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条下条指令地址的计算方式。

   【注】是否跳跃可能受到**状态寄存器**和**操作数**的控制，而跳跃到的地址分为**绝对地址**(由标记符直接得到)和**相对地址**(相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以**下一条指令仍然通过程序计数器(PC)给出**。

2. **数据寻址**

&emsp;&emsp;数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。

![4.2.1-1](C:\Users\HP\Desktop\组成原理\4.2.1-1.png)

#### 4.2.2 常见的数据寻址方式

1. **隐含寻址**

&emsp;&emsp;这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。

> 例：**单地址**的指令格式就不明显地在地址字段中指出第二个操作数的地址，规定**累加器(ACC)**作为第二个操作数地址。累加器(ACC)对单地址指令来说就是隐含寻址。

**优点**：缩短指令字长

**缺点**：增加存储器操作数或隐含地址的硬件。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-1.png" alt="4.2.2-1" style="zoom:80%;" />

2. **立即(数)寻址**

&emsp;&emsp;这种类型的指令的地址字段直接指出的不是操作数的地址，而是操作数的本身，又称为**立即数**。**数据采用补码的形式存放**。

**优点**：不访问主存，执行时间短。

**缺点**：A的位数限制了立即数的范围。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-2.png" alt="4.2.2-2" style="zoom:80%;" />

3. **直接寻址**

指令中的**形式地址A是操作数的真实地址EA**，即**EA=A**。

**优点**：简单，指令仅访问一次主存。

**缺点**：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-3.png" alt="4.2.2-3" style="zoom:80%;" />

4. **间接寻址**

&emsp;&emsp;**间接寻址是相对于直接寻址而言的**，指令的地址字段给出的形式地址不是操作数地址，而是操作数有效地址所在的存储单元，即**操作数地址的地址**，即**EA = (A)**。间接寻址可以是一次间接寻址，也可以是多次间接寻址。

**优点**：可扩大寻址范围(**有效地址EA的位数大于形式地址A的位数**)，便于编制程序(**用间接寻址可方便完成子程序的返回**)

**缺点**：指令在执行阶段需要多次访存，增大了时间开销。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-4.png" alt="4.2.2-4" style="zoom:80%;" />

5. **寄存器寻址**

&emsp;&emsp;寄存器寻址是指在指令字重直接给出操作数所在的寄存器编号，即$EA=R_i$，其操作数在$R_i$所指的寄存器内。

**优点**：不需要访问主存，执行速度快，**支持向量/矩阵运算**。

**缺点**：寄存器价格昂贵，计算机中的寄存器个数有限。

6. **寄存器间接寻址**

&emsp;&emsp;寄存器间接寻址是指在寄存器$R_i$中给出的不是操作数，而是操作数所在主存单元的地址，即$EA=(R_i)$。

**优点**：与一般间接寻址相比速度更快。

**缺点**：需要访问主存

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-5.png" alt="4.2.2-5" style="zoom:80%;" />

7. **相对寻址**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-16</font>

&emsp;&emsp;相对寻址是把程序计数器(PC)的内容加上形式地址A而形成的操作数的有效地址，即               **EA=(PC)+A**，其中A是相对于当前指令地址的位移量，可正可负，补码表示。

**优点**：操作数的地址不是固定的，它随PC值的变化而变化，且与指令之间总是相差一个固定值，因此**便于程序的浮动**。**相对寻址广泛利用于转移指令**。

**【注】**对于转移指令JMP A，当CPU从存储器中取出一个字节时，会自动执行(PC)+1->PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会自增2，即(PC) = X + 2，这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-6.png" alt="4.2.2-6" style="zoom:80%;" />

8. **基址寻址**

&emsp;&emsp;基址寻址是将CPU中的**基址寄存器(BR)**的内容加上指令格式中的形式地址A而形成操作数的有效地址。即**EA = (BR) + A**。其中基值寄存器既可以采用专用寄存器，又可以采用通用寄存器。

**优点**：可扩大寻址范围(**基址寄存器的位数大于形式地址A的位数**)，用户可以不用考虑自己的程序存于主存的哪个空间区域，有利于**多道程序的设计**，可用于**编制浮动程序**。

**缺点**：偏移量(形式地址A)的位数较短。

**【注1】**基址寄存器是**面向操作系统**的，其内容由操作系统或管理员确定，主要用于**解决程序逻辑空间与存储器的物理空间的无关性**。

**【注2】在程序执行的过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)**。采用通用寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍然是由操作系统确定。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-7.png" alt="4.2.2-7" style="zoom:80%;" />

9. **变址寻址**

&emsp;&emsp;变址寻址是指有效地址EA等于指令字中的形式地址A与**变址寄存器(IX)**的内容之和，即                 **EA = (IX) + A**。其中IX可为专业寄存器，也可以是通用寄存器。

**优点**：可扩大寻址范围(变址寄存器的位数大于形式地址A的位数)，**常用于数组处理**，可设定A为数组的首地址。**特别适合编制循环程序**。偏移量(变址寄存器IX)的位数足够以表示整个存储空间。

**【注】**变址寄存器是**面向用户的**，在程序执行的过程中，**变址寄存器可由用户改变(作为偏移量)，形式地址A不变(作为基地址)**。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-8.png" alt="4.2.2-8" style="zoom:80%;" />

10. **堆栈寄存器**

&emsp;&emsp;堆栈是存储器(或专用寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器为**堆栈指针(SP)**。堆栈可分为**硬堆栈**和**软堆栈**两种。

&emsp;&emsp;**寄存器堆栈又称为硬堆栈**。寄存器堆栈的成本比较高，不适合做大容量的堆栈；而从**主存划分一段区域做堆栈**是最常用的方法，这种堆栈称为**软堆栈**。

**【注】**采用堆栈结构的计算机系统中，**大部分指令表面上都表现为无操作数指令的形式**，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-9.png" alt="4.2.2-9" style="zoom:80%;" />



### 4.3 CISC和RISC的基本概念

#### 4.3.2 精简指令系统计算机(RISC)

<img src="C:\Users\HP\Desktop\组成原理\4-3-1.png" alt="4-3-1" style="zoom:80%;" />

#### 4.3.3 CISC和RISC的比较

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-17</font>

<img src="C:\Users\HP\Desktop\组成原理\4-3-2.png" alt="4-3-2" style="zoom:80%;" />



## 第5章 中央处理器

### 5.1 CPU的功能和基本结构

#### 5.1.1 CPU的功能

- 指令控制
- 操作控制
- 时间控制
- 数据加工
- 中断处理

#### 5.1.2 CPU的基本结构部

（1）运算器





（2）控制器



### 5.2 指令的执行过程

#### 5.2.1 指令周期

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-11</font>

1. **概念**

&emsp;&emsp;CPU从主存中每取出并执行一条指令所需的全部时间称为**指令周期**，即CPU完成一条指令的时间。

&emsp;&emsp;指令周期常用若干个**机器周期**来表示，一个机器周期又包含若干**时钟周期**(也称为**节拍**或**T周期**，它是CPU操作的最基本单位)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。
$$
\begin{align}
机器周期 &= 主存周期 \\
时钟周期 &= 计算机主频的倒数 \\
计算机主频 &= 1s时钟周期数
\end{align}
$$

<img src="C:\Users\HP\Desktop\组成原理\5.2.1-1.png" alt="5.2.1-1" style="zoom:95%;" />



![5.2.1-2](C:\Users\HP\Desktop\组成原理\5.2.1-2.png)





### 5.3 数据通路的功能和基本结构



### 5.4 控制器的功能和工作原理

#### 5.4.1 控制器的结构和功能

<img src="C:\Users\HP\Desktop\组成原理\5.4.1-1.png" alt="5.4.1-1" style="zoom:80%;" />

控制器包括**指令寄存器IR**和**程序计数器PC**，它是计算机系统的指挥中心，控制器主要功能有：

1）从主存取出一条指令，并指出下一条指令在主存中的位置。

2）对指令进行译码或测试，产生相应的操作控制信息，以便启动规定的动作。

3）指挥控制CPU、主存、输入和输出设备之间的数据流动方向。

#### 5.4.2 硬布线控制器

1. **硬布线控制单元图**

&emsp;&emsp;指令的操作码是决定控制单元发出不同操作命令(控制信号)的关键。CU的输入信号如下：

1）经指令译码器产生的指令信息。

2）时序系统产生的机器周期信号和节拍信号。

3）来自执行单元的反馈信息即标志。

<img src="C:\Users\HP\Desktop\组成原理\5.4.2-1.png" alt="5.4.2-1" style="zoom:80%;" />

2. **硬布线控制器的时序系统及微操作**<img src="C:\Users\HP\Desktop\组成原理\5.4.2-2.png" alt="5.4.2-2" style="zoom:80%;" /><img src="C:\Users\HP\Desktop\组成原理\5.4.2-3.png" alt="5.4.2-3" style="zoom:80%;" />

3. **CU的控制方式**

   1）同步控制方式	2）异步控制方式	3）联合控制方式



#### 5.4.3 微程序控制器

&emsp;&emsp;微程序设计思想是将每条机器指令编写成一个微程序，每个微程序包含若干个微指令，每个微指令对应一个或几个微操作命令。目前，**大多数计算机都采用微程序设计技术**。

1. **微程序控制的基本概念**

1）**微命令**和**微操作**：一条机器指令可分解成一个微操作系列，这些**微操作是计算机中最基本的、不可再分解的操作**。在微程序控制的计算机中，将**控制部件向执行部件发出各种控制命令称为微命令**，它是构成控制序列的最小单位。**微命令是微操作的控制信号，微操作是微命令的执行过程**。

**【注】**在组合逻辑控制器中也有微命令和微操作两个概念，它们并非是微程序控制器专有的。

2）**微指令**与**微周期**：微指令是若干微命令的集合。存放微程序指令的控制存储器的单元地址称为微地址。微指令通常至少包含两大部分信息：

​	① **操作控制字段**：又称为微操作码字段，用于产生某一步操作所需的各种操作控制信号。

​	② **顺序控制字段**：又称微地址码字段，用于控制产生下一条要执行的微指令地址。

3）**主存储器**与**控制存储器**：主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器(CM)用于存放微程序，在CPU内部，用ROM实现。

4）**程序**与**微程序**：程序是指令的有序集合，用于完成特定的功能；微程序是微指令的有序集合，**一条指令的功能由一段微程序来实现**。

**【注】微程序是不面向用户的**，它是由计算机设计者事先编制好并存放在控制存储器中的。程序是面向用户的，是由软件设计人员事先编制好放在主存或辅存的。

- **注意区分的几个寄存器**

  ① **地址寄存器(MAR)**：用于存放主存的读/写地址。

  ② **微指令寄存器(CMAR)**：用于存放控制存储器的读/写指令的地址。

  ③ **指令寄存器(IR)**：用于存放从主存中读出的指令。

  ④ **微指令寄存器(CMDR)**：用于存放从控制存储器中取出的微指令。



2. **微程序控制器的组成和工作过程**

**（1）微程序控制器的基本结构**

​	① **控制存储器**：它是微程序控制器的核心部件，用于存放各指令对应的微程序。

​	② **微指令寄存器(CMDR)**：用于存放从CM中取出的微指令，它的位数同微指令字长相等。

​	③ **微地址形成部件**：用于产生初始微地址和后继微地址，以保证微指令的连续执行。

​	④ **微地址寄存器(CMAR)**：接收微地址形成部件送来的微地址，为在CM中读取微指令做准备。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-1.png" alt="5.4.3-1" style="zoom:80%;" />

**（3）微程序和机器指令**

&emsp;&emsp;通常，一条机器指令对应一个微程序。**由于任何一条机器指令的取指令操作都是相同的，因此可以将取指令操作的微命令统一编成一个微程序**，这个微程序只负责将指令从主存单元中取出并送至寄存器。

**【注】**若指令系统中具有**n**种机器指令，则控制寄存器中的微程序数至少是**n+1(1为公共取指微操作)**。



3. **微指令的编码方式**

**（1）直接编码(直接控制)方式**

&emsp;&emsp;直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令对应位设置成1或0即可。

**优点**：简单、直观、执行速度快，操作并行性好。

**缺点**：微指令字长过长，n个微命令就要求微指令的操作字段有n位。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-2.png" alt="5.4.3-2" style="zoom:80%;" />

**（2）字段直接编码方式**

&emsp;&emsp;将微指令的微命令字段分成若干小字段，把**互斥性微命令组合在同一字段中**，把**相容性微命令组合在不同字段中**，每个字段独立编码。

- **微命令字段的分段原则**
  - 互斥性命令分别在同一段中，相容性微命令分别在不同段中
  - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间
  - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3时，最多只能表示7个互斥的微命令，通常用000表示不操作。

**优点**：可以缩短微指令字长

**缺点**：因为要通过译码电路后再发出微命令，因此执行速度慢

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-3.png" alt="5.4.3-3" style="zoom:80%;" />

**（3）字段间接编码方式**

&emsp;&emsp;一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出微命令，故称为字段间接编码，又称隐式编码。



4. **微指令的地址形成方式**

后继地址的形成主要有以下两大基本类型：

1）**直接由微指令的下地址段给出(断定方式)**

2）**根据机器指令的操作码形成**

微指令序列地址形成方式还有以下几种：<img src="C:\Users\HP\Desktop\组成原理\5.4.3-4.png" alt="5.4.3-4" style="zoom: 80%;" />



5. **微指令的格式**

**1）水平型微指令**：从编码上看。直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。指令字中的一位对应一个控制信号，有输出时为1，否则为0。**一条水平型指令定义并执行几种并行的基本操作**。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-5.png" alt="5.4.3-5" style="zoom:80%;" />

**优点**：微程序短，执行速度快

**缺点**：微指令长，编写微程序比较麻烦

**2）垂直型微指令**：垂直型微指令的特点是采用类似机器指令操作码方式，在微指令中设置操作码字段，采用微操作码编译法，由微操作码规定微指令的功能。**一条垂直型微指令只能定义并执行一种基本操作**。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-6.png" alt="5.4.3-6" style="zoom: 80%;" />

**优点**：微指令短、简单、规整，便于编写微程序。

**缺点**：微程序长，执行速度慢，工作效率低。

**3）混合型微指令**：在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度快。

- **水平微指令 VS 垂直型微指令**

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-7.png" alt="5.4.3-7" style="zoom:80%;" />



#### 5.4.4 微程序 VS 硬布线

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-19</font>

<img src="C:\Users\HP\Desktop\组成原理\5.4-1.png" style="zoom:75%;" />



### 5.5 指令流水线

#### 5.5.1 指令流水线的基本概念

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-18</font>



3. **流水线方式的特点**

（1）把一个任务(一条指令或一个操作)分解为**几个有联系的子任务**，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短执行时间。

（2）流水线每个功能部件后面都要有一个**缓冲寄存器**，或称为锁存器，其作用是保存流水段的执行结果，供给下一流水段使用。

（3）流水线中各个**功能段的时间应尽量相等**，否则会引起堵塞、断流。

（4）只有连续不断地提供同一种任务时才能发挥流水线的效率，所以流水线的中处理的必须是**连续任务**。

（5）流水线需要有**装入时间**和**排空时间**。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。





#### 5.5.3 影响流水线的因素

1. **结构相关(资源冲突)**

由于**多条指令在同一时刻争用同一资源**形成的冲突称为结构相关，有以下解决方案：

（1）前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期。

（2）单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重配置。



2. **数据相关(数据冲突)**

&emsp;&emsp;数据相关是指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令记为数据相关。解决方法如下

（1）**暂停一个周期或多个周期**，直到数据相关问题消失后再执行。可分为**硬件阻塞(stall)**和**软件插入“NOP”指令**两种方法。

（2）**设置相关专用通路**，即不等前一条指令把结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令ALU计算结果作为自己输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这也称为**数据旁路技术**。

（3）**调整指令顺序**。



3. **控制相关(控制冲突)**

当流水线遇到**转移指令**和**其它改变PC值的指令**而造成断流时，会引起控制相关。解决方法如下：

（1）**对转移指令进行分支预测，尽早生成转移目标地址**。分支预测分**简单(静态)预测**和**动态预测**。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态调整，有较高的预测准确率。

（2）预测转移成功和不转移成功两个控制流方向上的目标指令。

（3）加快和提前形成条件码。

（4）提高转移方向的猜准率。



## 第6章 总线

### 6.1 总线概述

#### 6.1.1 总线基本概念

1. **总线的定义**

总线是一组能为多个部件分时共享的公共信息传送线路。**分时**和**共享**是总线的两个特征。

- **分时**：同一时刻只允许有一个部件向总线发送信息。
- **共享**：总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。

2. **总线设备**

- **主设备**：总线的主设备是指获得总线控制权的设备。
- **从设备**：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。

3. **总线特性**

- **机械特征**：尺寸、形状
- **电气特性**：传输方向和有效的电平范围
- **功能特性**：每根传输线的功能
- **时间特性**：信号和时序的关系

4. **总线的猝发式传输方式**

在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为**猝发传送**。



#### 6.1.4 总线的性能指标

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-20</font>

（1）**总线的传输周期**：指一次总线操作所需的时间(包括**申请阶段**、**寻址阶段**、**传输阶段**和**结束阶段**)，简称**总线周期**。总线传输周期通常由若干**总线时钟周期**构成。

（2）**总线时钟周期**：即**机器的时钟周期**。机器有一个统一的时钟，以控制整个计算机各个部件，总线也要受此时钟的控制。

（3）**总线的工作频率**：总线上各种操作的频率，为**总线周期的倒数**。实际上指1s内传送几次数据。若
$$
总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
$$
（4）**总线的时钟频率**：即**机器的时钟频率**，它为**时钟周期的倒数**。

（5）**总线宽度**：又称**总线位宽**，它是总线上同时能传输的数据位数，通常指数据总线的根数，如32根称为32位总线。

（6）**总线的带宽**：可以理解为**总线的数据传输率**，即单位时间内总线上可以传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用**字节/秒(B/s)**。
$$
总线带宽=总线工作频率 \times (总线宽度/8)
$$
（7）**总线复用**：总线复用指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。

（8）**信号线数**：**地址总线**、**数据总线**和**控制总线**3种总线数的总和称为信号线数。其中，总线的最主要性能指标为**总线宽度**、**总线(工作)频率**、**总线带宽**。







## 第7章 输入/输出系统



### 7.3 I/O接口

I/O接口(I/O)控制器是**主机和外设之间的交接界面**，通过接口可以实现主机和外设之间的信息交换。

#### 7.3.1 I/O接口的功能

**（1）实现主机和外设的通信联络控制**：解决主机与外设时序的配合问题，协调不同工作速度的外设和主机之间的交换信息。

**（2）进行地址译码和设备选择**：CPU送来外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机与指定的外设交换信息。

（3）**实现数据缓冲**：CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，避免因速度不一致而丢失数据。

（4）**信号格式的转换**：电平转换、并/串或串/并转换、模/数或数/模转换等。

（5）**传送控制命令和状态信息**：CPU要启动某一外设时，通过接口中的**命令寄存器**向外设发送启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的**状态寄存器**，并反馈给CPU。外设向CPU提出中断请求和DMA请求时，CPU也应有相应的响应信号反馈给外设。

#### 7.3.2 I/O接口的基本结构

<img src="C:\Users\HP\Desktop\组成原理\7.3.2-1.png" alt="7.3.2-1" style="zoom:85%;" />

- **内部接口**：内部接口与系统总线相连，实际上是**内存、CPU**相连。数据的传输方式只能是**并行传输**。
- **外部接口**：外部接口通过接口电缆与外设相连，外部接口的数据传输只能是**串行方式**。

I/O接口与CPU之间的I/O总线有**数据线**、**命令线**和**地址线**。

- **命令线**和**地址线**都是**单向传输**的，从CPU传送给I/O接口，而**I/O接口中的命令字**、**状态字**及**中断类型号**均是I/O接口发往CPU的，故只能通过**I/O总线的数据线**传输。

【注】**接口和端口是两个不同的概念**。端口是指接口电路中可以进行**读/写的寄存器**，若干端口加上相应的控制逻辑才可以组成接口。



### 7.4 I/O方式



#### 7.4.2 程序中断方式



2. 程序中断方式工作流程



**（4）中断隐指令**

2012选

&emsp;&emsp;CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由**硬件直接实现**的，将它称为中断隐指令。

&emsp;&emsp;中断隐指令并不是指令系统中一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下

①**关中断**：在中断服务程序中，为了保护中断现场(即CPU主要寄存器中的内容)期间不被新的中断所打断，必须关中断。

②**保存断点**：为保证在中断服务程序执行完毕后能正确返回到原来的程序，必须将原来的断点(即**程序计数器PC的内容**)保存起来。

③**引出中断服务程序**：引出中断服务程序的实质是，取出中断服务程序的入口地址并传送给程序计数器(PC)。



6. **中断处理过程**

- **允许嵌套中断的处理流程**

![7.4.2-1](C:\Users\HP\Desktop\组成原理\7.4.2-1.png)

- **不允许嵌套中断的处理流程**

1）关中断 -> 2）保存断点 -> 3）识别中断源 -> 4）保护现场 -> 5）中断处理事件 -> 6）恢复现场 -> 7）开中断 -> 8）中断返回



