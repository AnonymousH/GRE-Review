## 第1章 计算机系统概述

### 1.1 操作系统的基本概念

#### 1.1.2 操作系统的特征

​	（1）并发	（2）共享	（3）虚拟	（4）异步

**【注】**现代操作系统最基本的两个特征是：**并发**与**共享**

#### 1.1.3 操作系统的目标和功能







## 第2章 进程的管理

### 2.1 进程与线程

#### 2.1.1 进程的概念和特征

1. **进程的概念**

&emsp;&emsp;在多道程序环境下，允许多个程序并发执行，此时它们将失去**封闭性**，并具有**间断性**及**不可再现性**的特征，为此引入了进程概念。

【注1】**程序段**、**相关数据段**和**PCB**三部分构成了进程映象(**进程实体**)。**PCB是进程存在的唯一标志**。所谓创建进程，实际上是创建进程映象中的PCB；而撤销进程，实际上是撤销进程的PCB。

【注2】**进程实体是静态的，进程是动态的**。我们可以把传统的操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”。

2. **进程的特征**

   **1）动态性**。进程是一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。**动态性是进程最基本的特征**。

   **2）并发性**。指多个进程同时存在于内存中，能在一段时间内同时运行。**并发性是进程的重要特征**。

   **3）独立性**。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序，都不能作为一个独立的单位参与运行。

   **4）异步性**。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可知的速度推进。

   **5）结构性**。每个进程都配置一个PCB对其描述。进程实体都是由**程序段**、**数据段**和**进程控制块**三部分组成的。



#### 2.1.6 线程概念和多线程模型

1. **线程的基本概念**

&emsp;&emsp;引入进程的目的是为了更好地使用多道程序并发执行，提高资源利用率和系统吞吐率，增加并发程度；而引进线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

【注1】线程由**线程ID**、**程序计数器**、**寄存器集合**和**堆栈**组成。

【注2】线程是一个基本的CPU执行单元，也是程序执行流最小单元。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行。线程也有**就绪**、**阻塞**和**运行**三种状态。

2. **线程与进程的比较**

|          | 进程                                                   | 线程                                                         |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 调度     | 在没有引入线程的操作系统中，进程是独立调度的基本单位。 | 引入线程后的操作系统中，线程是独立调度的基本单位。在同一进程中线程的切换不会引起进程的切换，在不同进程中进行线程切换，会引起进程切换。 |
| 资源     | 不管系统是否支持线程，进程是资源分配和拥有的基本单位   | 线程不拥有系统资源，但线程可以访问其所属进程的系统资源。     |
| 并发性   | 进程间可以并发执行                                     | 线程间可以并发执行                                           |
| 系统开销 | 创建或撤销进程的开销远远大于创建或撤销线程时的开销     | 线程切换时只需保存和设置少量的寄存器内容                     |
| 地址空间 | 进程的地址空间之间互相独立                             | 同一进程的各线程间共享进程的地址空间                         |
| 通信     | 进程间通信(IPC)需要进程同步和互斥手段的辅助            | 线程可以直接读/写进程数据段(如全局变量)来进行通信            |

在用户级线程中，有关线程管理的所有工作都由应用程序完成，无需内核的干预，内核意识不到线
程的存在。





### 2.2 处理机调度



#### 2.2.2 处理机调度的时机

&emsp;&emsp;进程调度和切换程序是操作系统**内核程序**。请求调度事件发生后，才可能运行进程调度程序。调度了新的就绪进程后，才会进行进程间的切换。理论上这三件事应该顺序执行，但在实际设计中，操作系统内核程序运行时，若某时发生了引起进程调度的因素，则不一定能马上进行进程调度与切换。

- 线代操作系统中，**不能**进行进程的调度与切换的情况有以下几种【2012年选择】：

（1）**在处理机中断的过程**。

（2）**进程在操作系统内核程序临界区中**。

（3）**其它需要完全屏蔽中断的原子操作过程中**。如加锁、解锁、中断保护现场、恢复等原子操作。

- **应该进行进程调度和切换**的情况如下：

（1）**发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度和切换**。属于**非剥夺调度**。

（2）**中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换**。属于**剥夺调度**。



### 2.4 死锁

#### 2.4.1 死锁的概念

1. **死锁的定义**

&emsp;&emsp;多道程序的并发执行会带来死锁现象，这是指多个进程因竞争资源而造成的一种僵局(相互等待)，若无外力作用，这些进程都将无法向前推进。

2. **死锁产生的原因**

**（1）系统资源的竞争**

&emsp;&emsp;通常系统中拥有不可剥夺资源，其数量不足以满足多个进程运行的需求，使得进程在运行时陷入僵局，如磁带机、打印机等。**只有对不可剥夺资源的竞争才可能产生死锁，对于可剥夺资源的竞争是不会产生死锁的**。

**（2）进程推进顺序非法**

**（3）死锁产生的必要条件**

产生死锁必须同时满足以下4个条件，只要其中任意一个条件不成立，死锁就不会发生。

- **互斥条件**：即在一段时间内某资源仅为一个进程所占有，其它请求进程只能等待。
- **不剥夺条件**：进程获得的资源在未使用完之前，不能被其它进程强行夺走，只能是主动释放。
- **请求并保持等待**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
- **循环等待条件**：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求。

#### 2.4.2 死锁的处理策略

1. **死锁预防**

设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个，以防止产生死锁。

2. **避免死锁**

在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。

3. **死锁的检测及解除**

&emsp;&emsp;无须采取任何限制性措施，允许在运行过程中发生死锁。通过系统检查出死锁的发生，然后采取某种措施解除死锁。

<img src="C:\Users\HP\Desktop\操作系统\2.4.2-1.png" alt="2.4.2-1" style="zoom:85%;" />





## 第3章 内存管理

### 3.1 内存管理概念

#### 3.1.1 内存管理的基本原理和要求

1. **内存管理的功能**

**1）内存空间的分配与回收**：由操作系统完成主存储器空间的分配与管理。

**2）地址转换**：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储器管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。

**3）内存空间的扩充**：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。

**4）存储保护**：保证各道作业在各自的存储空间内运行，互不干扰。

2. **程序的装入和链接**

创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：

- **编译**：由编译程序将用户源代码编译成若干目标模块，这一过程会形成**逻辑地址**。(2011选)

- **链接**：由链接程序将编译后形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块。有以下三种方式

​	**（1）静态链接**：在程序运行前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。

​	**（2）装入时动态链接**：将用户程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。

​	**（3）运行时动态链接**：对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。其优点是便于修改与更新，便于实现对目标模块的共享。

- **装入**

**（1）绝对装入**：逻辑地址和物理地址完全相同。

**（2）可重定位装入(静态重定位)**：根据内存的情况，将装入模块装入内存适当的位置。其特点是。一个作业装入内存时，必须给它分配全部的内存空间，整个运行期间就不能在内存中移动，也不能再申请内存空间。

**（3）动态运行时装入(动态重定位)**：装入程序把装入模块装入内存后，并不立即把模块中的相对地址转换为绝对地址，而是把这种地址的转换推迟到真正要执行时才进行。



#### 3.1.3 连续分配管理方式

1. **单一连续分配(单道)**

&emsp;&emsp;内存在此方式下分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；用户区还是用户提供的、除系统区之外的内存空间。**内存中永远只有一道程序**。

2. **固定分区分配(多道)**

&emsp;&emsp;内存在此方式下划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。

![3.1.3-1](C:\Users\HP\Desktop\操作系统\3.1.3-1.png)

&emsp;&emsp;为了便于内存分配，通常将分区大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)。

![3.1.3-2](C:\Users\HP\Desktop\操作系统\3.1.3-2.png)

3. **动态分区分配(多道)**

&emsp;&emsp;动态分区分配又称可变分区分配，是一种动态划分内存的方法。这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好合适进程的需要。因此，系统中分区的大小和数目是可变的。

![3.1.3-3](C:\Users\HP\Desktop\操作系统\3.1.3-3.png)

&emsp;&emsp;动态分区的分配策略：

​		**1）首次适应(First Fit)算法**：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大		小能满足要求的第一个空闲分区。

​		**2）最佳适应(Best Fit)算法**：空闲区按容量递增的方式形成分区链，找到第一个能满足要求的空		闲分区。

​		**3）最坏适应(Worst Fit)算法**：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链   		接。找到第一个能满足要求的空闲分区，即挑选出最大的分区。

​		**4）邻近适应(Next Fit)算法**：又称循环首次适应算法，由首次适应算法演变而成。不同之处是，		分配内存时从上一次查找结束的位置开始继续查找。

**【注】**以上3种内存分区管理方式对比

![3.1.3-4](C:\Users\HP\Desktop\操作系统\3.1.3-4.png)



### 3.2 虚拟内存管理

#### 3.2.1 虚拟内存的基本概念

1. **虚拟存储器的主要特性**

   （1）**多次性**	（2）**对换性**	（3）**虚拟性**





#### 3.2.3 页面置换算法

选择调出页面的算法就称为**页面置换算法**。



4. **时钟(CLOCK)置换算法**

&emsp;&emsp;简单的CLOCK算法给每帧关联一个附加位，称为**使用位**。当某页首次装入主存时，将该帧的使用位置为1。对于页替换算法，用于替换的候选帧集合可以视为一个**循环缓冲区**，并有一个指针与之相关联。

&emsp;&emsp;当某一页被替换时，将使用位置1，并将该指针指向下一帧。当需要替换一页时，操作系统扫描缓冲区，以便找使用位为0的帧。每当遇到一个使用位为1的帧，操作系统将该位重新置为0；若在这个过程开始时，缓冲区中所有的帧使用位为0，则选择遇到的第一个帧替换；若所有帧的使用位均为1，则指针在缓冲区中完整的循环一遍，把所有使用位都置为0，并停留在最初的位置上，替换该帧中的页。

&emsp;&emsp;CLOCK又称**最近未用(Not Recently Used, NRU)算法**。

- **改进型CLOCK算法**

每帧都处于以下4种情况之一：

1）最近未被访问，也未被修改(u = 0, m = 0)

2）最近被访问，但未被修改(u = 1, m = 0)

3）最近未被访问，但被修改(u = 0, m = 1)

4）最近被访问，被修改(u = 1, m = 1)

**算法流程：**

（1）从指针的当前位置开始，扫描帧缓冲区，在这次扫描过程中，对使用位不做任何修改，选择遇到的第一个帧(u = 0, m = 0)用于替换。

（2）若第（1）步失败，则重新扫描，查找(u = 0, m = 1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对于每个跳过的帧，将它的使用位置成0。

（3）若第（2）步失败，则指针将回到它最初位置，且集合所有帧的使用位均为0，重复第（1) 步，并且有必要，重复第（2）步，以便可以找到供替换的帧。





## 第4章 文件系统

### 4.1 文件系统基础

#### 4.1.2 文件的逻辑结构

1. **无结构文件(流式文件)**

&emsp;&emsp;以**字节**为单位，由于无结构文件没有结构，因而对记录的访问只能通过**穷举搜索**的方式。那些对基本信息单位操作不多的文件适于采用字符流的无结构方式，如**源程序文件**、**目标代码文件**等。

2. **有结构文件(记录式文件)**

   **1）顺序文件：**文件记录顺序排列，记录通常是定长的，可以**顺序存储**或**链表形式存储**。

   **2）索引文件：**支持可变长记录的**随机访问**。

   **3）索引顺序文件：**是顺序文件和索引文件两种组织形式的结合。

   **4）直接文件或散列文件**

#### 4.1.3 目录结构

&emsp;&emsp;与文件管理系统和文件集合相关联的是文件目录，它包含文件的信息如属性、位置和所有权等，这些信息主要由操作系统进行管理。

1. **文件控制块和索引结点**

   **1）文件控制块(FCB)：**用来存放控制文件所需的各种信息的数据结构，以实现“**按名存取**”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。

   **2）索引结点：**$文件目录项=文件名+索引结点$

2. **目录结构**

   **1）单级目录结构：**在整个文件系统中只建立一张目录表，每个文件占一个目录项。

![4.1-1](C:\Users\HP\Desktop\操作系统\4.1-1.png)

​		**缺点：**查找速度慢，不允许重名，不便于文件共享。

​		**2）两级目录结构：**解决了重名问题，但是缺乏灵活性，但不利于文件分类。

![4.1-2](C:\Users\HP\Desktop\操作系统\4.1-2.png)

​		**3）多级目录结构(树形目录结构)：**将两级目录结构的层次关系加以推广，就形成了多级目录结构。能有效的进行文件的管理和保护，但是会增加磁盘的访问次数。易于实现文件分类，但不便于实现文件共享。

![4.1-3](C:\Users\HP\Desktop\操作系统\4.1-3.png)

- **绝对路径**：从根目录出发的路径，如/dev/hda

- **相对路径：**从当前目录出发，可用cd命令改变当前目录

  **4）无环图目录结构：**实现了文件共享，需要在共享结点处设置一个共享计数器，每当图中增加对该结点的共享链时，计数器加1；每当有用户提出删除该结点时，计数器减1。仅当计数器为0时，才真正删除该结点，否则仅删除请求用户的共享链。

![4.1-4](C:\Users\HP\Desktop\操作系统\4.1-4.png)

#### 4.14 文件共享

1. **基于索引结点的共享方式(硬连接)**

![4.1-5](C:\Users\HP\Desktop\操作系统\4.1-5.png)



![4.1-6](C:\Users\HP\Desktop\操作系统\4.1-6.png)

2. **基于符号链实现文件共享(软链接)**

&emsp;&emsp;只有文件的拥有者才拥有指向其索引结点的指针。而共享文件的其它用户只有**该文件的路径名**，不拥有指向其索引结点的指针。



### 4.2 文件系统的实现



#### 4.2.3 文件实现(物理结构)

文件的实现就是研究文件的**物理结构**，即文件数据存储在物理存储设备上是如何分布和组织的。

1. **文件分配方式**

文件发分配对应于文件的物理结构，是指如何为文件分配磁盘块。

**（1）连续分配**：连续分配方法要求每个文件在磁盘块上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业**访问磁盘时需要的寻道数和寻道时间最小**。**会产生外部碎片**。

<img src="C:\Users\HP\Desktop\操作系统\4.2.3-1.png" alt="4.2.3-1" style="zoom:90%;" />

**（2）链接分配**

- **隐式链接**：每个文件对应一个**磁盘块链表**；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都有指向下一个盘块的指针，这些指针对于用户是透明的。**目录包括文件第一块的指针和最后一块的指针**。

<img src="C:\Users\HP\Desktop\操作系统\4.2.3-2.png" alt="4.2.3-2" style="zoom:90%;" />

- **显示链接**：把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显示地存放在内存的一张**链接表**中。每个表项中存放对应块的下一块指针，即下一个盘块号。例如在隐式链接分配中对应的链接表为：

  | 盘块号 | 内容 |
  | ------ | ---- |
  | 1      | 10   |
  | ...    | ...  |
  | 10     | 25   |
  | ...    | ...  |

  由于分配给该文件的所有盘块号都放在了该表，故称该表为**文件分配表（File Allocation Table，FAT）**。

**（3）索引分配**：把每个文件的所有盘块号都集中放在一起构成**索引块(表)**，每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第$i$个条目指向文件的第$i$个块。目录条包括索引块的地址。要读第$i$块，通过索引块的第$i$个条目的指针来查找和读入所需的块。

<img src="C:\Users\HP\Desktop\操作系统\4.2.3-3.png" alt="4.2.3-3" style="zoom:90%;" />

- **解决索引块大小的机制**

  - **链接方式**：一个索引块通常为一个磁盘块，因此它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。
  - **多层索引**：多层索引使用第一层索引块指向第二层索引块，第二层索引块再指向文件块。这种方法可以根据文件的大小继续到第三层或更高层。

  > 例如：4096B的块，能在索引块中存入1024个4B的指针，两层索引允许1048576个数据块，即允许的最大文件为4GB。

  - **混合索引**：将多种索引分配方式相结合的分配方式。例如：系统采用直接地址，又采用单级索引分配方式或两级索引分配方式。

<img src="C:\Users\HP\Desktop\操作系统\4.2.3-4.png" alt="4.2.3-4" style="zoom:98%;" />

![4.2.3-5](C:\Users\HP\Desktop\操作系统\4.2.3-5.png)



### 4.3 磁盘组织与管理

#### 4.3.2 磁盘调度算法

一次磁盘读写操作时间由寻找(寻道)时间、延迟时间和传输时间决定。

1）**寻找时间**$T_s$：活动头磁盘在读写信息前，将磁头移动到指定磁道所需的时间。这个时间除跨越$n$条磁道的时间外，还包括启动磁臂的时间$s$，即
$$
T_s = m \times n +s
$$
2）**延迟时间**$T_r$：磁头定位到某一磁道的扇区(块号)所需要的时间，设磁盘的旋转速度为$r$，则
$$
T_r = \frac{1}{2r}
$$

> 典型的旋转速度为5400转/分，相当于一周：
> $$
> \frac{1}{2r}=\frac{1 \times60 \times10^3ms}{2 \times 5400} \approx5.55ms
> $$

3）**传输时间**$T_t$：从磁盘读出或向磁盘写入数据所经历的时间，这个是时间取决于每次所读/写的字节数$b$和磁盘的旋转速度，即
$$
T_t = \frac{b}{rN}
$$
式中，$r$为磁盘每秒的旋转速度，$N$为一个磁盘上面的字节数。

目前常用的磁盘调度算法有以下几种：

**（1）先来先服务(FCFS)算法**

![4.3.2-1](C:\Users\HP\Desktop\操作系统\4.3.2-1.png)

> 例如，磁盘请求队列中的请求序分别为55,58,39,18,90,160,150,38,184，磁头的初始位置是磁道100，采用FCFS算法时磁头运动如图，磁头共移动了
> $$
> (45+3+19+21+72+70+10+112+146)=498
> $$
> 平均寻找长度 = 498/9 = 55.3

**（2）最短寻找时间优先(SSTF)算法**

SSTF算法是选择调度处理的磁道是当前磁头距离最近的磁道，以便使每次的寻找时间最短。**这种算法会产生“饥饿”现象**。

![4.3.2-2](C:\Users\HP\Desktop\操作系统\4.3.2-2.png)

>例如，磁盘请求队列中的请求序分别为55,58,39,18,90,160,150,38,184，磁头的初始位置是磁道100，采用SSTF算法时磁头运动如图，磁头共移动了
>$$
>10+32+3+16+1+20+132+10+24=248
>$$
>平均寻找长度 = 248/9 = 27.5

**（3）扫描(SCAN)算法(又称电梯调度算法)**

![4.3.2-3](C:\Users\HP\Desktop\操作系统\4.3.2-3.png)

>例如，磁盘请求队列中的请求序分别为55,58,39,18,90,160,150,38,184，磁头的初始位置是磁道100。采用SCAN算法时，不但要知道磁头的当前位置，而且要知道磁头的移动方向，假设磁头沿磁道号增加的顺序移动，则移动磁道的顺序为100,150,160,184,200,90,58,55,39,38,18。磁头共移动了
>$$
>(50+10+24+16+110+32+3+16+1+20)=282
>$$
>平均寻道长度为 = 282/9 = 31.3

**（4）循环扫描(C-SCAN)算法**

在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。

![4.3.2-4](C:\Users\HP\Desktop\操作系统\4.3.2-4.png)

>例如，磁盘请求队列中的请求序分别为55,58,39,18,90,160,150,38,184，磁头的初始位置是磁道100。采用C-SCAN算法时，假设磁头沿磁道号增大的顺序移动，移动的顺序为100,150,160,184,200,0,18,38,39,55,58,90。磁头共移动了
>$$
>50+10+24+16+200+18+20+1+16+3+32=390
>$$
>平均寻道长度 = 390/9 = 43.33

- LOOK调度**

![4.3.2-5](C:\Users\HP\Desktop\操作系统\4.3.2-5.png)

- **C-LOOK调度**

![4.3.2-6](C:\Users\HP\Desktop\操作系统\4.3.2-6.png)

**【注】4种磁盘调度算法的比较**

![4.3.2-7](C:\Users\HP\Desktop\操作系统\4.3.2-7.png)



## 第5章 输入/输出设备

### 5.1 I/O管理概述



#### 5.1.3 I/O子系统的层次结构

![5.1.3-1](C:\Users\HP\Desktop\操作系统\5.1.3-1.png)

（1）**用户I/O软件**：实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。一般而言，大部分的I/O软件都在操作系统内部，但仍有一小部分在用户层，用户层软件必须通过一组系统调用来获得操作系统的服务。

（2）**设备独立性软件**：设备独立性也称为设备无关性，使得应用程序独立于具体使用的物理设备，为实现设备独立性引用了**逻辑设备**和**物理设备**两个概念。

逻辑设备的好处是：①**增加设备分配的灵活性**；②**易于实现I/O重定向**，指用于I/O操作的设备可以更换，而不必改变应用程序。

设备独立性软件的主要功能有：①**执行所以设备的公有操作**。②**向用户层(或文件层)提供统一接口**。

（3）**设备驱动程序**：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。没类设备配置一个设备驱动程序，通常以**进程**的形式存在。

（4）**中断处理程序**：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回到被中断进程。

**任务**：进行上下文切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。

（5）**硬件设备**：I/O设备通常包括一个**机械部件**和一个**电子部件**。电子部件称为**设备控制器**(或**适配器**)。

- 设备控制器的**主要功能**如下：

①**接收和识别CPU或通道发来的命令**，如磁盘控制器能接收读、写、查找等命令。

②**实现数据交换**，包括设备与控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。

③**发现和记录设备及自身的状态信息**，供CPU处理使用。

④**设备地址识别**。

- 设备控制器的主要**组成部分**

①**设备控制器与CPU的接口**。该接口有三类信号线：数据线、地址线和控制线。

②**设备控制器与设备的接口**。一个接口连接一台设备，每个接口中都存在数据、状态和控制三种类型的信号。

③**I/O控制逻辑**。用于实现对设备的控制。



### 5.2 I/O核心子系统



#### 5.2.3 高速缓存与缓冲区

1. **高速缓存**

&emsp;&emsp;磁盘高速缓存**逻辑上属于磁盘**，**物理上则是驻留在内存中的盘块**。高速缓存在内存中分为两种形式：一种是在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定；另一种是是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。

2. **缓冲区**

- **目的**

1）缓和CPU与I/O设备间速度不匹配的矛盾。

2）减少CPU的中断频率，放宽对CPU响应时间的限定。

3）解决基本数据单元大小(即数据粒度)不匹配的问题。

4）提高CPU和I/O设备之间的并行性。

- **方法**

  **1）硬件缓冲器**	**2）缓冲区(位于内存区域)**

**缓冲区特点**：当缓冲区的数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后，才能从缓冲区把数据传出。

假设从磁盘把一块**数据输入缓冲区的时间**为$T$，操作系统**将该缓冲区中的数据传输到用户区的时间**为$M$，而CPU对这**一块数据处理的时间**为$C$。

**（1）单缓冲**

处理每块数据的用时为
$$
\max(C,T)+M
$$
**（2）双缓冲**

处理每块数据的用时为
$$
\max(C+M,T)
$$
当$C+M < T$时，则可使设备连续输入；若$C+M>T$时，则可以使CPU不必等待设备输入。

**（3）循环缓冲**

&emsp;&emsp;包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环。

&emsp;&emsp;需要两个指针in和out，int指针指向可以输入数据的第一个空缓冲区；out指针指向可以提取一个装满数据的缓冲区。

**（4）缓冲池**

由多个系统共用的缓冲区组成，缓冲区按其使用情况可以形成三个队列：**空缓冲队列**、**装满输入缓冲队列(输入队列)**和**装满输出数据队列(输出队列)**。

![5.2.3-1](C:\Users\HP\Desktop\操作系统\5.2.3-1.png)

3. **高速缓存与缓冲区的对比**

![5.2.3-2](C:\Users\HP\Desktop\操作系统\5.2.3-2.png)





### 5.5 指令流水线

#### 5.5.1 指令流水线的基本概念



3. **流水线方式的特点**

（1）把一个任务(一条指令或一个操作)分解为**几个有联系的子任务**，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短执行时间。

（2）流水线每个功能部件后面都要有一个**缓冲寄存器**，或称为锁存器，其作用是保存流水段的执行结果，供给下一流水段使用。

（3）流水线中各个**功能段的时间应尽量相等**，否则会引起堵塞、断流。

（4）只有连续不断地提供同一种任务时才能发挥流水线的效率，所以流水线的中处理的必须是**连续任务**。

（5）流水线需要有**装入时间**和**排空时间**。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。





#### 5.5.3 影响流水线的因素

1. **结构相关(资源冲突)**

由于多条指令在同一时刻争用同一资源形成的冲突称为结构相关，有以下解决方案：

（1）前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期。

（2）单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重配置。

2. **数据相关(数据冲突)**

&emsp;&emsp;数据相关是指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令记为数据相关。解决方法如下

（1）**暂停一个周期或多个周期**，直到数据相关问题消失后再执行。可分为**硬件阻塞(stall)**和**软件插入“NOP”指令**两种方法。

（2）**设置相关专用通路**，即不等前一条指令把结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令ALU计算结果作为自己输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这也称为**数据旁路技术**。

（3）**调整指令顺序**。

3. **控制相关(控制冲突)**

当流水线遇到**转移指令**和**其它改变PC值的指令**而造成断流时，会引起控制相关。解决方法如下：

（1）**对转移指令进行分支预测，尽早生成转移目标地址**。分支预测分**简单(静态)预测**和**动态预测**。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态调整，有较高的预测准确率。

（2）预测转移成功和不转移成功两个控制流方向上的目标指令。

（3）加快和提前形成条件码。

（4）提高转移方向的猜准率。













