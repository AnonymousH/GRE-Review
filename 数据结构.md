## 第2章：线性表

### 2.1 线性表的定义和基本操作



#### 2.1.2 线性表的基本操作

- InitList(&L)：**初始化表**。返回一个空的线性表。
- Length(L)：**求表长**。返回线性表L的长度，即L中元素的个数。
- LocateElem(L,e)：**按值查找操作**。在表L中查找具有给定关键字值的元素。
- GetElem(L,i)：**按位查找操作**。获取表L中的第i个位置的元素。
- ListInsert(&L,i,e)：**插入操作**。在表L中的第i个位置插入指定元素e。
- ListDelect(&L,i,&e)：**删除操作**。删除表L中的第i个位置的元素，并用e返回删除元素的值。
- PrintList(L)：**输出操作**。按前后的输出顺序输出线性表L的所有元素值。
- Empty(L)：**判空操作**。若L为空表，则返回ture，否则返回false。
- DestroyList(&L)：**销毁操作**。销毁线性表，并释放线性表L所占用的内存空间。 





### 2.2 线性表的顺序表示

#### 2.2.1 顺序表的定义

&emsp;&emsp;线性表的顺序存储又称为**顺序表**。它是用一组地址连续的存储单元依次存储线性表中的数据单元，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

![2.2.1-1](C:\Users\HP\Desktop\数据结构\2.2.1-1.png)

- 假定线性表中的元素类型为ElemType，则线性表的顺序存储类型描述为

```c
#define MaxSize 50	//定义线性表的最大长度
typedef struct{
    ElemType data[MaxSize];	//顺序表的元素
    int length;				//顺序表当前长度
}SqList;					//顺序表的类型定义
```

- 动态数组分配

```c
#define InitSize 100	//表长度的初始定义
typedef struct{
    ElemType *data;		//指示动态分配数组的指针
    int	MaxSize,length	//数组的最大容量和当前个数
}SqList;				//顺序表的类型定义
```

C的初始动态分配语句

```
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)
```

C++初始动态分配语句

```c++
L.data = new ElemType(InitSize);
```



### 2.3 线性表的链式表示

&emsp;&emsp;顺序表的插入、删除操作需要移动大量的元素，影响了运行效率，由此引入了线性表的链式存储。链式存储不要求连续的存储单元，即它不要求逻辑上相邻的两个元素物理上也相邻。对线性表的插入、删除不需要移动元素，只需修改指针即可。

#### 2.3.1 单链表的定义

&emsp;&emsp;线性表的链式存储又称为单链表，它是通过任意一组存储单元来存储线性表中的数据元素。

- 单链表结点类型的描述

```c++
typedef struct LNode{	//定义单链表结点类型
    ElemType data;		//数据域
    struct LNode *next;	//指针域
}LNode,*LinkList;
```

&emsp;&emsp;通常用一个**头指针**来标识一个链表，如单链表$L$，头指针为NULL时表示一个空表，为了方便，在单链表第一个结点前附加一个结点，称为**头结点**。头结点的数据域不含有任何信息，指针域指向线性表的第一个元素结点。

![2.3.1-1](C:\Users\HP\Desktop\数据结构\2.3.1-1.png)

- **头指针和头结点的区分**

&emsp;&emsp;不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内不存储信息。

- **引入头结点后的优点**：

（1）由于开始结点的位置被放置在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其它位置上的操作一致，无需特殊处理。

（2）无论链表是否为空，其头指针都指向头结点而非空指针，因此空表和非空表的处理也得到了统一。





## 第3章：栈和队列



### 3.3 栈和队列的应用

#### 3.3.1 中缀表达式转后缀表达式

算法流程

1、任何中缀表达式都由运算数，运算符，括号（大，中，小），这三部分组成。

2、从中缀表达式的左边开始扫描，若遇到运算数时，则直接将其输出，不压入堆栈。

3、若遇到左括号，则将其压栈。

4、若遇到右括号，表达括号内的中缀表达式已经扫描完毕。这时需将栈顶的运算符依次弹出并输出，直至遇到左括号，左括号弹出但不输出。

5、若遇到的是运算符：

​	a、如果该运算符的优先级大于栈顶运算符的优先级时，将其压栈

​	b、如果该运算符的优先级小于栈顶运算符的优先级时，将栈顶运算符弹出并输出，接着和新的栈顶运算 符比较，若大于，则将其压栈，若小于，继续将栈顶运算符弹出并输出......(一直递归下去，直至运算符大于栈顶云算符为止)。

6、最后一步，若扫描到中缀表达式的末尾[即扫描结束]，若堆栈中还有存留的运算符依次弹出并输出即可。

>  比如将:2*(9+6/3-5)+4转化为后缀表达式2 9 6 3 / +5 - * 4 + 
>
> （1）out：2                                                                          stack：
>
> （2）out：2                                                                          stack：*
>
> （3）out：2                                                                          stack： *  （
>
> （4）out：2    9                                                                    stack ：*   （
>
> （5）out：2    9                                                                    stack ：*   （ +     
>
> ​																								注：**在堆栈中括号的优先级最低**
>
> （6）out：2    9   6                                                               stack ：*   （ +
>
> （7）out ：2   9   6                                                               stack ：*   （ +   /
>
> （8）out ：2   9   6    3                                                         stack ：*   （ +  /
>
> （9）out ：2   9   6   3    /                                                     stack ：*   （ +   
>
> （10）out： 2   9   6   3    /   +                                              stack : *     (   
>
> （11）out：2   9   6  3   /    +                                                stack : *     (   -
>
> （12）out : 2    9   6  3   /    +   5                                           stack : *    （ -   遇到了右括号
>
> （13）out：2   9   6  3   /   +    5   -                                       stack：*   （      
>
> （14）out：2  9   6   3   /   +    5   -                                       stack：*
>
> （15）out：2  9   6   3   /   +   5    -                                       stack ：*    括号弹出但不输出
>
> （16）out ：2   9    6   3   /   +   5   -   *                                 stack  :           遇到了+
>
> （17）out：2   9  6   3   /  +   5   -    *                                    stack ：+
>
> （18）out：2  9  6   3   /  +   5  -    *   4                                 stack  : +
>
> （19）out：2   9   6   3   /  +  5  -  *  4  +                              stack ：
> 





## 第4章：树与二叉树

### 4.1 树的基本概念

#### 4.1.3 树的性质

（1）树中的结点数等于所有结点度数加1。

（2）度为$m$的树中第$i$层上至多有$m^{i-1}$个结点($i \geq 1$)

（3）高度为$h$的$m$叉树至多有$(m^h-1)/(m-1)$和结点

**【注】**推导公式：$S=m^{k-1}+m^{k-2}+\dots+m+1=(m^h-1)/(m-1)$

（4）具有$n$个结点的$m$叉树的最小高度为$\biggl\lceil \log_m(n(m-1)+1) \biggr\rceil\qquad$



![4.1.2-1](C:\Users\HP\Desktop\数据结构\4.1.2-1.png)

### 4.3 二叉树的遍历和线索二叉树

#### 4.3.2 线索二叉树

> 在有$n$个结点的二叉树中，有$n+1$个空指针。这是因为每个叶子结点有2个空指针，而每个度为1的结点有1个空指针，总的空指针为$2n_0+n_1$，又$n_0=n_2+1$，所以总的空指针为：
> $$
> n_0+n_1+n_2 = n+1
> $$

【注】：$n_0 = n_2 + 1$怎么来的？

&emsp;&emsp;在二叉线索树中规定：**若无左子树，令lchild指向其前驱点**；**若无右子树，令rchild指向其后继结点**。还需要增加两个标志域表明当前指针对象是指向左(右)子结点还是指向直接前驱(后继)。

![4.3.2-1](C:\Users\HP\Desktop\数据结构\4.3.2-1.png)

其中，标志域的含义如下：

![4.3.2-2](C:\Users\HP\Desktop\数据结构\4.3.2-2.png)

- **线索二叉树的存储结构描述**

```c
typedef struct ThreadNode{
    ElemType data;	//数据元素
    struct ThreadNode *lchild,*rchild;	//左、右孩子指针
    int ltag,rtag;	//左、右线索标志
}ThreadNode,*ThreadNode;
```



### 4.4 树、森林

#### 4.4.2 树、森林与二叉树的转换

1. **树$\rightarrow$二叉树**

**规则**：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻兄弟结点，可表示为**“左孩子右兄弟”**。由于根结点没有兄弟，所以由树转换而得到的二叉树没有右子树。

<img src="C:\Users\HP\Desktop\数据结构\4.4.2-1.png" alt="4.4.2-1" style="zoom:90%;" />

2. **森林$\rightarrow$二叉树**

将森林转换为二叉树的步骤是：

（1）先把每棵树转换为二叉树；

（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。

<img src="C:\Users\HP\Desktop\数据结构\4.4.2-2.png" alt="4.4.2-2" style="zoom:75%;" />

3. **二叉树$\rightarrow$树**

二叉树转换为树是树转换为二叉树的逆过程，其步骤是：

（1）若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；

（2）删除原二叉树中所有结点与其右孩子结点的连线；

（3）整理（1）和（2）两步得到的树，使之结构层次分明。

<img src="C:\Users\HP\Desktop\数据结构\4.4.2-3.png" alt="4.4.2-3" style="zoom:75%;" />

4. **二叉树$\rightarrow$森林**

二叉树转换为森林比较简单，其步骤如下：

（1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；

（2）把分离后的每棵二叉树转换为树；

（3）整理第（2）步得到的树，使之规范，这样得到森林。

![4.4.2-4](C:\Users\HP\Desktop\数据结构\4.4.2-4.png)



###4.5 树与二叉树的应用

#### 4.5.1 二叉排序树

1. **二叉排序树的定义**

&emsp;&emsp;**二叉排序树(BST)**，也称为**二叉查找树**。二叉排序树或者是一颗空树，或者是一颗具有下列特性的非空二叉树：

​	1）若左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。

​	2）若右子树非空，则右子树上所有结点的关键字均大于根结点的关键字。

​	3）左、右子树本身也是一颗二叉排序树。

对二叉排序树进行**中序遍历**可以得到一个**从小到大**的序列，如图，得到的序列为123468。

![4.5.1-1](C:\Users\HP\Desktop\数据结构\4.5.1-1.png)



#### 4.5.2 平衡二叉树(AVL)

1. **定义**

&emsp;&emsp;规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，这样的二叉树称为**平衡二叉树(Balanced Binary Tree)**，简称为**平衡树(AVL)**。

2. **平衡二叉树的插入**

   **1）LL平衡旋转(右单旋转)**

![4.5.2-1](C:\Users\HP\Desktop\数据结构\4.5.2-1.png)

​		**2）RR平衡旋转(左单旋转)**

![4.5.2-2](C:\Users\HP\Desktop\数据结构\4.5.2-2.png)

​		**3）LR平衡旋转(先左后右双旋转)**

![4.5.2-3](C:\Users\HP\Desktop\数据结构\4.5.2-3.png)

​		**4）RL平衡旋转(先右后左旋转)**

![4.5.2-4](C:\Users\HP\Desktop\数据结构\4.5.2-4.png)



## 第5章：图

### 5.1 图的基本概念

#### 5.1.1 图的定义



3. **简单图**

一个图$G$若满足：**(1)不存在重复边**；**(2)不存在顶点到自身的边**，则图$G$称为简单图。





### 5.4 图的应用



#### 5.4.4 关键路径

2011大

- **AOE网**

&emsp;&emsp;在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销(如完成活动所需的时间)**，则称这种有向图用边表示活动的网络，简称为AOE网。

- **性质**

（1）只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；

（2）只有在进入某一顶点的各有向边所代表的活动都已结束时，该顶点所代表的时间才能发生；

- **几个概念**

（1）**源点**：AOE网中仅有一个入度为0的顶点，称为**开始顶点(源点)**。

（2）**汇点**：AOE网中仅存在一个出度为0的顶点，称为**结束顶点(汇点)**。

（3）**关键路径、关键活动**：从源点到汇点的所有路径中，具有最大路径的长度的路径称为关键路径，而把路径上的活动称为关键活动。

- **寻找关键活动**

1. **事件$v_k$的最早发生时间$v_e(k)$**

   从开始顶点$V$到$V_k$的最长路径长度。事件的最早发生时间决定了所有从$V_k$开始的活动能够开工的最早时间。可以用下面的递推公式计算：
   $$
   \begin{aligned}
   &v_e(源点)=0 \\
   &v_e(k)=\max \{v_e(j)+Weight(v_j,v_k)\}
   \end{aligned}
   $$
   $Weight(v_j,v_k)$表示$<v_j,v_k>$上的权值。

   **【注】**在计算$v_e(k)$时是按**从前往后**的顺序计算的。

2. **事件$v_k$的最迟发生时间$v_l(k)$**

   该时间是指在不推迟整个工程完成的前提下，即保证它所指向的事件$v_i$在$v_e(i)$时刻能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：
   $$
   \begin{aligned}
   &v_l(汇点)=v_e(汇点) \\
   &v_l(j)=\min \{v_l(k)-Weight(v_j,v_k)\}
   \end{aligned}
   $$
   **【注】**在计算$v_r(k)$时是**从后往前**计算的。

3. **活动$a_i$的最早开始时间$e(i)$**

   该时间是指该活动的起点所表示的事件最早发生的时间。若边$<v_k,v_j>$表示活动$a_i$，则有$e(i)=v_e(k)$

4. **活动$a_i$的最迟开始时间$ l(i)$**

   该时间是指该活动的终点所表示的最迟发生时间与该活动所需时间之差，若边$<v_k,v_j>$表示活动$a_i$，则有$l(i)=v_l(j)-Weight(v_k,v_j)$

5. **一个活动$a_i$的最迟开始时间$l(i)$和其最早开始时间$e(i)$的差额$d(i)=l(i)-e(i)$**

   它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间。若一个活动的时间余量为0，则说明该活动必须如期完成，否则就会拖延完成整个工程的进度，所以称$l(i)-e(i)=0$即$l(i)=e(i)$的活动是**关键活动**。

- **求关键路径的算法步骤**

1）求AOE网络中所有**事件**的**最早发生时间**$v_e() $。

2）求AOE网络中所有**事件**的**最迟发生时间**$v_l()$。

3）求AOE网络中所有**活动**的**最早开始时间**$e()$。

4）求AOE网络中所有**活动**的**最迟开始时间**$l()$。

5）求AOE网络中所有活动的**差额**$d()$，找出所有$d()=0$的活动构成**关键路径**。

- **例子**

该例子得到的关键路径为$(v_1,v_3,v_4,v_6)$

![5.4.4-1](C:\Users\HP\Desktop\数据结构\5.4.4-1.png)

**【注1】**关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可加快关键活动来缩短整个工程的工期，但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能变成非关键活动。

**【注2】**网络中的关键路径并不唯一，且对于有几条关键路径的网，只提供一条关键活动的速度并不能缩短整个工程的工期，只有加快那些包含在所有关键路径上的关键活动才能达到缩短工期的目的。





## 第6章：查找



### 6.3 B树与B+树

#### 6.3.1 B树及其基本操作

&emsp;&emsp;B树，又称多路平衡查找树，B树中所有结点的孩子结点数的最大值称为B树的阶，通常用$m$表示。一颗$m$阶B树或为空树，或为满足如下特性的$m$阶树：

1）树中每个结点至多有$m$颗子树(即至多含有$m-1$个关键字)

2）若根结点不是终端结点，则至少有两颗子树

3）除根结点外的所有非叶子结点至少有$\biggl\lceil m/2 \biggr\rceil$颗子树(即至少含有$\biggl\lceil m/2 \biggr\rceil -1$个关键字)。

4）所有非叶子结点的结构如下：

![6.3.1-1](C:\Users\HP\Desktop\数据结构\6.3.1-1.png)

其中，$K_i(i=1,2,\dots,n)$为结点的关键字，且满足$K_1 < K_2 < \dots <K_n$，

$P_i(i=1,2,\dots,n)$为指向子树中所有结点的关键字均大于$K_i$。

结点中关键字个数$n$满足$\biggl\lceil m/2 \biggr\rceil -1 \le n \le m-1 $

5）所有叶子结点都在同一层上，并且不带信息。

![6.3.1-2](C:\Users\HP\Desktop\数据结构\6.3.1-2.png)



#### 6.3.2 B+树的基本概念

一颗$m$阶的B+树需要满足下列条件

1）每个分支节点最多有$m$颗子树

2）非叶子结点至少两颗子树，其它每个结点至少有$\biggl\lceil m/2 \biggr\rceil$颗子树

3）结点的子树个数 = 关键字个数

4）**所有叶结点包含全部关键字**及指向相应记录的指针，叶结点中将关键字按大小排列，并且相邻叶结点按大小顺序相互链接起来。

 5）所有分结点(可视为索引结点)中仅包含它的各个子结点(即下一级的索引块)中关键字的最大值及其指向其子结点的指针。

![6.3.2-1](C:\Users\HP\Desktop\数据结构\6.3.2-1.png)

通常在B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶子结点。即可以对B+树进行两种查找运算：(1) **从最小关键字开始的顺序查找**； （2）**从根结点开始的多路查找**。

- $m$**阶的B+树与$m$阶的B树的主要差别**

（1）在B+树中，具有$n$个关键字的结点只有$n$棵子树，即每个关键字对应一颗子树；而在B树中，具有$n$个关键字的结点含有$n+1$课子树。

（2）在B+树中，每个结点(非根内部结点)的关键字个数$n$的范围是$\biggl\lceil m/2 \biggr\rceil  \le n \le m $；而在B树中，具有每个结点(非根内部结点)的关键字个数$n$的范围是$\biggl\lceil m/2 \biggr\rceil -1 \le n \le m-1 $。(根结点是：$1\le n \le m-1$)

（3）在B+树中，叶结点包含信息，所有非叶子结点仅索引作用，非叶子结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。

（4）在B+树中，叶结点包含了全部关键字，即在非叶子结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其它结点包含的关键字是不重复的。





### 6.4 散列表

#### 6.4.1 散列表的基本概念

1. **散列函数**

&emsp;&emsp;一个把查找表中的关键字映射成该关键字对应的地址的函数，记为
$$
Hash(key) = Addr
$$
&emsp;&emsp;散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**，这些发生碰撞的不同关键字称为**同义词**。

2. **散列表**

&emsp;&emsp;根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

#### 6.4.2 散列函数的构造方法

1. **直接定址法**

$$
H(key)=a \times key +b
$$

其中，$a$和$b$是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位比较多，则会造成存储空间的浪费。

2. **除留余数法**

&emsp;&emsp;假定散列表长为$m$，取一个不大于$m$但接近或等于$m$的质数$p$，散列函数为
$$
H(key)=key \% p
$$
除留余数法的关键是选好$p$，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。

**【注】**以上是经常用到的两种散列函数，一般题目会给出具体的散列函数。

#### 6.4.3 处理冲突的方法

1. **开放地址法**

&emsp;&emsp;所谓开放地址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为
$$
H_i = (H(key)+d_i)\% m
$$
其中，$i=0,1,2,\dots,k(k \leq m-1)$，$m$表示散列表表长，$d_i$为增量序列。

​	**1）线性探测法**。当$d_i=0,1,\dots,m-1$时，称为线性探测法。会造成大量元素**“聚集”(或堆积)**现象，大大降低了查找效率。、

​	**2）平方探测法**。当$d_i=0^2,1^2,-1^2,\dots,k^2,-k^2$时，称为平方探测法，其中$k \leq m/2$，散列表长度$m$必须是一个可以表示成$4k+3$的素数，又称为**二次探测法**。它是一个比较好的处理冲突的方法，可以避免“堆积”问题，它的缺点是不能探测散列表上的所有单元，但至少能探测到一半单元。

2. **拉链法(链接法)**

&emsp;&emsp;对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个散列表由其散列地址唯一标识。

> 例如，关键字序列为{19,14,23,01,68,20,84,27,55,11.10,79}，散列函数H(key) = key%3，用拉链法处理冲突，建立的表如图所示

![6.4.3-1](C:\Users\HP\Desktop\数据结构\6.4.3-1.png)

#### 6.4.4 散列查找及性能分析

&emsp;&emsp;散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：

> 初始化：Addr=Hash(key)
>
> （1）检查表中地址为Addr的位置上是否有记录，若无记录，返回失败；若有标记，比较它与key的值，若相等，则返回查找成功标志，否则执行（2）
>
> （2）用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入（1）

- 散列表的查找效率取决于三个因素：**散列函数**、**处理冲突的方法**和**装载因子**。

- **装载因子**$\alpha$

$$
\alpha = \frac{表中的记录n}{散列表的长度m}
$$

散列表的**平均查找长度**取决于散列表的装载因子$\alpha$，而不直接依赖于$n$或$m$，直观地看，$\alpha$越大，表示装载的记录越“满”，发生冲突的可能性越大，反之发生的冲突可能性越小。



## 第7章：排序

### 7.2 插入排序

#### 7.2.1 直接插入排序

![7-1](C:\Users\HP\Desktop\数据结构\7-1.png)

- 要将元素$L[i]$插入到已有序的子序列$L[1\dots i-1]$中，需要执行以下操作：

​	1）查找出$L[i]$在$L[1\dots i-1]$中的插入位置$k$

​	2）将$L[k\dots i-1]$中的所有元素全部后移一个位置

​	3）将$L[i]$复制到$L[k] $

- **算法实现**

```c++
void InsertSort(ElemType A[],int n) {
    int i,j;
    for(i = 2;i <= n;i++) { //依次将A[2]-A[n]插入到前面已排序序列
        if(A[i].key < A[i-1].key) { //若A[i]的关键码小于前驱，需要将A[i]插入有序表
            A[0] = A[i];	//复制为哨兵，A[0]不存放元素
            for(j = i-1;A[0].key < A[j].key;--j) //从后往前查找待插入位置
                A[j+1] = A[j]	//向后挪位
            A[j+1] = A[0] 		//复制到插入位置
        }
    }   
}
```

- **例子**

![7-2](C:\Users\HP\Desktop\数据结构\7-2.jpg)

- **性能分析**

**比较次数和移动次数取决于待排序表的初始状态**。

最好的情况是表中元素已经有序，最坏的情况是表中的元素是逆序。



#### 7.2.2 折半插入排序

&emsp;&emsp;从前面的直接插入排序算法中，不难看出每趟插入的过程中，都进行了两项工作：**(1)从前面的子表中查找出待插入元素应该被插入的位置**；**(2)给插入位置腾出空间，将待插入元素复制到表中的插入位置**。该算法中，总是**边比较边移动元素**。

&emsp;&emsp;可以分离比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动插入位置之后的所有元素。

```c++
void InsertSort(ElemType A[],int n) {
    int i,j,low,high,mid;
    for(i = 2;i < n;i++) {  	//依次将A[2]~A[n]插入到前面已排序的序列
     	A[0] = A[i]   			//将A[i]暂存到A[0]
        low = 1;hight = i-1;	//设置折半查找范围
        while(low<=high) {		//折半查找(默认递增有序)
            mid = (low+high)/2; //取中间点
            if(A[mid].key > A[0].key)	//查找右半子表
                high = mid - 1;			
           	else						//查找左半子表
                low = mid + 1;
        }
        for(j = i-1;j >= high+1;--j)
            A[j+1] = A[j];		//统一元素往后移动
        A[high+1] = A[0];		//插入操作
    }
}
```

**比较次数和移动次数与表的初始状态无关**。

