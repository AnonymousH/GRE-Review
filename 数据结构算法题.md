## 第2章：线性表

###2.2 线性表的顺序表示

#### 2010

- **题目描述**

&emsp;&emsp;设将n (n>1) 个整数存放到一维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p (0<p<n) 个位置，即将R中的数据由$(X_0，X_1，\dots，X_{n-1})$变换为$（X_p，X_{p+1},\dots ,X_0,X_1,\dots,X_{p-1})$。

- **算法思想**

&emsp;&emsp;可以将这个问题看做把数组ab转换成数组$ba$(a代表数组的前p个元素，b代表数组中余下的n-p个元素)，先将a逆置得到$a^{-1}b$，最后将整个$b$逆置得到$a^{-1}b^{-1}$，最后将整个$a^{-1}b^{-1}$逆置得到$(a^{-1}b^{-1})^{-1}=ba$。设Reserve函数将数组元素逆置的操作，对abcdefgh向左循环移动3(p=3)个位置如下：

>Reverse(0,p-1)得到cbadefgh
>
>Reserve(p,n-1)得到cbahgfed
>
>Reservr(0,n-1)得到defghabc

Reserve中的两个参数分别表示数组中待缓缓元素的始末位置。 

- **算法实现**

```c
void Reverse(int R[],int from,int to){
    int i,temp;
    for(i=0;i<(to-from+1)/2;i++){
        temp = R[from+i];
        R[from+i] = R[to-i];
        R[to-i] = temp;
    }
}
void Converse(int R[],int n,int p){
    Reserve(R,0,p-1);
    Reserve(R,p,n-1);
    Reserve(R,0,n-1);
}
```

- **复杂度分析**

&emsp;&emsp;上述算法中三个Reserve函数的时间复杂度分别为$O(p/2),O((n-p)/2),O(n/2)$，故算法的复杂度为$O(n)$，空间复杂度为$O(1)$

- **另解1**

&emsp;&emsp;创建大小为p的辅助数组S，将R前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将暂存在S中的p个元素依次放回R中的后续单元。

&emsp;&emsp;时间复杂度：$O(n)$，空间复杂度：$O(n) $

- **另解2**

&emsp;&emsp;创建大小为n的辅助数组S，将R的前p个元素暂存在S的后p个单元中，后n-p个元素暂存在S的前n-p个单元中，最后将S中的所有元素一一赋值回R。

&emsp;&emsp;时间复杂度：$O(n)$，空间复杂度：$ O(n) $



### 2.3 线性表的链式表示

#### 2009

- **题目描述**

&emsp;&emsp;已知一个带有头结点的单链表，结点结构为：

<img src="C:\Users\HP\Desktop\数据结构\2009-42.png" alt="2009-42" style="zoom:80%;" />

&emsp;&emsp;假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的data域值，并返回1；否则，返回0。

- **算法思想**

&emsp;&emsp;定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)。p指针沿链表移动；当p移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。以上过程对链表仅进行一遍扫描。

- **算法步骤**

① count = 0，p和q指向链表表头结点的下一个结点；

② 若p为空，转⑤；

③ 若count等于k，则q指向下一个结点；否则，count = count + 1；

④ p指向下一个结点，转②

⑤ 若count等于k，则查找成功，输出该结点的data域值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0；

⑥ 算法结束。

- **算法实现**

```c
typedef int ElemType;
typedef struct LNode{
    ElemType data;		//数据域
    struct LNode *next; //指针域
}*LinkList,LNode;
int Search_k(LinkList list, int k){
    LinkList p = list->next,q = list->next;		//指针p,q指向链表第一个结点
    int count = 0;								//计数器，记录是否到达第k个结点
    while(p != NULL){
        if(count < k)	count++;				//继续向前移动，表示未到达k
        else
            q = q->next;						//与指针p同步移动
        p = p->next;
    }
    if(count < k)
        return 0;								//查找失败
    else{
        printf("%d",q->data);					//输出数据域
        return 1;
    }
}
```





