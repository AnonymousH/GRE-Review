## 第2章：线性表

###2.2 线性表的顺序表示

#### 2010：将一个线性表中的元素循环左移p个位置

- **题目描述**

&emsp;&emsp;设将n (n>1) 个整数存放到一维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p (0<p<n) 个位置，即将R中的数据由$(X_0，X_1，\dots，X_{n-1})$变换为$（X_p，X_{p+1},\dots ,X_0,X_1,\dots,X_{p-1})$。

- **算法思想**

&emsp;&emsp;可以将这个问题看做把数组ab转换成数组$ba$(a代表数组的前p个元素，b代表数组中余下的n-p个元素)，先将a逆置得到$a^{-1}b$，最后将整个$b$逆置得到$a^{-1}b^{-1}$，最后将整个$a^{-1}b^{-1}$逆置得到$(a^{-1}b^{-1})^{-1}=ba$。设Reserve函数将数组元素逆置的操作，对abcdefgh向左循环移动3(p=3)个位置如下：

>Reverse(0,p-1)得到cbadefgh
>
>Reserve(p,n-1)得到cbahgfed
>
>Reservr(0,n-1)得到defghabc

Reserve中的两个参数分别表示数组中待缓缓元素的始末位置。 

- **算法实现**

```c
void Reverse(int R[],int from,int to){
    int i,temp;
    for(i=0;i<(to-from+1)/2;i++){
        temp = R[from+i];
        R[from+i] = R[to-i];
        R[to-i] = temp;
    }
}
void Converse(int R[],int n,int p){
    Reserve(R,0,p-1);
    Reserve(R,p,n-1);
    Reserve(R,0,n-1);
}
```

- **复杂度分析**

&emsp;&emsp;上述算法中三个Reserve函数的时间复杂度分别为$O(p/2),O((n-p)/2),O(n/2)$，故算法的复杂度为$O(n)$，空间复杂度为$O(1)$

- **另解1**

&emsp;&emsp;创建大小为p的辅助数组S，将R前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将暂存在S中的p个元素依次放回R中的后续单元。

&emsp;&emsp;时间复杂度：$O(n)$，空间复杂度：$O(n) $

- **另解2**

&emsp;&emsp;创建大小为n的辅助数组S，将R的前p个元素暂存在S的后p个单元中，后n-p个元素暂存在S的前n-p个单元中，最后将S中的所有元素一一赋值回R。

&emsp;&emsp;时间复杂度：$O(n)$，空间复杂度：$ O(n) $



#### 2011：求两个线性表的中位数

- **题目描述**

&emsp;&emsp;一个长度为$L$($L \ge 1$)的升序序列$S$，处在第$\lceil L/2 \rceil$个位置的数称为$S$中的中位数。例如，若序列$S1=(11,13,15,17,19)$，则$S1$的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若$S2=(2,4,6,8,20)$，则$S1$和$S2$的中位数是11。现有两个等长升序序列$A$和$B$，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列$A$和$B$的中位数。

- **算法设计思想**

&emsp;&emsp;分别求出序列A和B的中位数，设为a和b，求序列A和B的中位数过程如下：

1）若a=b，则a或b即为所求的中位数，算法结束

2）若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求舍弃的长度相等

3）若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度相等

在保留的两个升序序列中，重复1）、2）、3），直到两个序列中只含一个元素为止，较小者即为所求的中位数。

- **算法实现**

```c
int M_Search(int A[],int B[],int n){
    int s1=0,d1=n-1,m1,s2=1,d2=n-1,m2;
    //分别表示序列A和B的首位数、末位数和中位数
    while(s1!=d1||s2!=d2){
        m1=(s1+d1)/2;
        m2=(s2+d2)/2;
        if(A[m1]==B[m2])
            return A[m1];	//满足条件1)
        if(A[m1]<B[m2]){	//满足条件2)
            if((s1+d1)%2==0){	//元素个数为奇数
                s1=m1;	//舍弃A中间点以前的部分且保留中间点
                d2=m2;	//舍弃B中间点以后的部分且保留中间点
            }
            else{		//元素个数为偶数
                s1=m1+1;	//舍弃A中间点及中间点以前部分
                d2=m2;		//舍弃B中间点以后部分且保留中间点
            }
        }
        else{	//满足条件3)
            if((s1+d1)%2==0){	//元素个数为奇数
                d1=m1;	//舍弃A中间点以后的部分且保留中间点
                s2=m2;	//舍弃B中间点以前的部分且保留中间点
            }
            else{		//元素个数为偶数
                d1=m1+1;	//舍弃A中间点及中间点以后部分
                s2=m2;		//舍弃B中间点以前的部分且保留中间点
            }
        }
    }
    return A[s1]<B[s2]?A[s1]:B[s2];
}
```

- **时间复杂度分析**

算法的时间复杂度为$O(\log_2n)$,空间复杂度为$O(1)$。

- **另解1**

&emsp;&emsp;给序列A和B设定两个浮标 i 和 j 分别指向A、B的第一个元素，即初始值为0。A、B中的元素根据浮标所对应的元素不停的比较，若A[i] > B[j]，则i+1，否则j+1。当i+j==n-1时停止比较，此时的A和B的中位数已经找到，中位数为min{A[i],B[j]}。

&emsp;&emsp;时间复杂度为：$O(n)$，空间复杂度为：$ O(1) $



#### 2013 找出序列主元素

- **题目描述**

&emsp;&emsp;已知一个整数序列$A=(a_0,a_1,\dots,a_{n-1})$，其中$0\le a_i \le n(0 \le i \le n)$。若存在$a_{p1}=a_{p2}=\dots =a_{pm}=x$且$m>n/2(0\le p_k < n,1\le k \le m)$，则称$x$为主元素。例如$A=(0,5,5,3,5,7,5,5)$，则5为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$没有主元素。假设$A$的$n$个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素；否则输出-1。

- **算法思想**

&emsp;&emsp;算法的策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素num，然后重新计数，确认num是否是主元素。

&emsp;&emsp;算法可分为如下两步：

&emsp;&emsp;① 选取候选主元素：依次扫描所给数组中的每个整数，将第一个遇到的整数num保存到c中，记录num的出现次数为1；若遇到下一个整数仍等于num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮的计数，即从当前位置开始重复上述过程，知道扫描完全部数组元素。

&emsp;&emsp;② 判断c中元素是否是真正的主元素；再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素；否则，序列中不存在主元素。

- **算法实现**

```c
int Majority(int A[],int n){
    int i,c,count = 1;		//c用来保存候选主元素，count用来计数
    c = A[0];				//设置A[0]为候选主元素
    for(i=1;i<n;i++){
     	if(A[i]==c)
            count++;		//对A中的候选主元素计数
        else
            if(count>0)		//处理不是候选主元素
                count--
            else{
                c = A[i];
                count = 1;
            }
    }
    if(i=count=0;i<n;i++)
        if(A[i]==c)
            count++;
    if(count>n/2)	
        return c;			//确定候选主元素
    else
        return -1;			//不存在主元素
}
```



- **复杂度分析**

算法时间复杂度：$O(n)$，空间复杂度：$O(1) $

- **另解1**

&emsp;&emsp;使用一个和序列同等长度的辅助数组**(其下标就是序列的元素，下标对应的值即序列元素出现的次数)**存储序列中的不同元素出现的个数，然后再扫描一遍辅助数组选出元素的下标，返回该下标，否则返回-1。

时间复杂度：$O(n)$，空间复杂度：$O (n) $



### 2.3 线性表的链式表示

#### 2009：寻找单链表的倒数第k个结点

- **题目描述**

&emsp;&emsp;已知一个带有头结点的单链表，结点结构为：

<img src="C:\Users\HP\Desktop\数据结构\2009-42.png" alt="2009-42" style="zoom:80%;" />

&emsp;&emsp;假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的data域值，并返回1；否则，返回0。

- **算法思想**

&emsp;&emsp;定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)。p指针沿链表移动；当p移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。以上过程对链表仅进行一遍扫描。

- **算法步骤**

① count = 0，p和q指向链表表头结点的下一个结点；

② 若p为空，转⑤；

③ 若count等于k，则q指向下一个结点；否则，count = count + 1；

④ p指向下一个结点，转②

⑤ 若count等于k，则查找成功，输出该结点的data域值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0；

⑥ 算法结束。

- **算法实现**

```c
typedef int ElemType;
typedef struct LNode{
    ElemType data;		//数据域
    struct LNode *next; //指针域
}*LinkList,LNode;
int Search_k(LinkList list, int k){
    LinkList p = list->next,q = list->next;		//指针p,q指向链表第一个结点
    int count = 0;								//计数器，记录是否到达第k个结点
    while(p != NULL){
        if(count < k)	count++;				//继续向前移动，表示未到达k
        else
            q = q->next;						//与指针p同步移动
        p = p->next;
    }
    if(count < k)
        return 0;								//查找失败
    else{
        printf("%d",q->data);					//输出数据域
        return 1;
    }
}
```



#### 2012：寻找保存单词的单链表的共享后缀

- **题目描述**

&emsp;&emsp;假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示。

<img src="C:\Users\HP\Desktop\数据结构\2012-42-1.png" alt="2012-42-1" style="zoom:80%;" />

&emsp;&emsp;设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为![2012-42-2](C:\Users\HP\Desktop\数据结构\2012-42-2.png)，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。

- **算法思想**

&emsp;&emsp;顺序遍历两个链表到尾结点时，并不能保证两个链表同时到达尾结。这是因为两个链表的长度不同。

&emsp;&emsp;假设一个链表比另一个链表长k个结点，我们先在长链表上遍历k个结点，之后同步遍历两个链表，这样就能保证它们同时到达最后一个结点。由于两个链表从第一个公共结点到链表的尾结点都是重合的，所以它们肯定能同时到达第一个公共结点。算法的基本设计思想如下：

&emsp;&emsp;① 分别求出str1和str2所指的两个链表的长度m和n；

&emsp;&emsp;② 将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点，若m>=n，则使p指向链表中的第m-n+1个结点；若m<n，则使q指向链表中的第n-m+1个结点，即使指针p和q所指的结点到表尾的长度相等。

&emsp;&emsp;③ 反复将指针p和q同步向后移动，并判断它们是否指向同一个结点。若p和q指向同一个结点，则该结点即为所求的公共后缀的起始位置。

- **算法实现**

```c
LinkNode *Find_1st_Common(LinkList str1,LinkList str2){
    int len1 = Length(str1),len2 = Length(st2);
    LinkNode *p,*q;
    for(p=str1;len1>len2;len1--)	//使p指向链表q与指向的链表等长
        p=p->next;
    for(q=str2;len1<len2;len2--)	//使q指向链表p与指向的链表等长
        q=q->next;
    while(p->next!=NULL&&p->next!=q->next){ //查找公共后缀起始点
        p=p->next;
        q=q->next;
    }
    return p->next;	//返回公共后缀的起始点
}
```

- **算法复杂度**

时间复杂度为：$O(\max(len1,len2))$，空间复杂度为：$O(1)$